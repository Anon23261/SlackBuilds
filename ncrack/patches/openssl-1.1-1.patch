From 1c2f805e65e2e1231ecbe2ba1e5d83245c240da3 Mon Sep 17 00:00:00 2001
From: Hilko Bengen <bengen@hilluzination.de>
Date: Mon, 11 Dec 2017 17:06:13 +0100
Subject: [PATCH] (wip) Port opensshlib to OpenSSL 1.1

---
 crypto.cc                   |  21 ++--
 modules/ncrack_ssh.cc       |   4 +-
 opensshlib/cipher-3des1.c   |  66 +++++-----
 opensshlib/cipher-bf1.c     |  27 ++--
 opensshlib/cipher.c         |  61 +++++-----
 opensshlib/cipher.h         |   2 +-
 opensshlib/dh.c             |  34 +++---
 opensshlib/dh.h             |   2 +-
 opensshlib/digest-openssl.c |  17 +--
 opensshlib/kexdhc.c         |  11 +-
 opensshlib/kexgexc.c        |  13 +-
 opensshlib/rsa.c            |  26 ++--
 opensshlib/ssh-dss.c        |  29 +++--
 opensshlib/ssh-ecdsa.c      |  12 +-
 opensshlib/ssh-rsa.c        |   9 +-
 opensshlib/sshkey.c         | 291 +++++++++++++++++++++++++++++---------------
 16 files changed, 384 insertions(+), 241 deletions(-)

diff --git a/crypto.cc b/crypto.cc
index 342b72c..6000199 100644
--- a/crypto.cc
+++ b/crypto.cc
@@ -418,28 +418,27 @@ void rsa_encrypt(uint8_t *input, uint8_t *output, int length,
     uint8_t *mod_bin, uint32_t mod_size, uint8_t *exp_bin)
 {
   uint8_t input_temp[256];
-  BIGNUM val1, val2, bn_mod, bn_exp;
-  BN_init(&bn_mod); BN_init(&bn_exp); BN_init(&val1); BN_init(&val2);
+  BIGNUM *val1 = BN_new(), *val2 = BN_new(), *bn_mod = BN_new(), *bn_exp = BN_new();
 
   BN_CTX *bn_ctx = BN_CTX_new();
   memcpy(input_temp, input, length);
   mem_reverse(input_temp, length);
   mem_reverse(mod_bin, mod_size);
   mem_reverse(exp_bin, 4);
-  BN_bin2bn(input_temp, length, &val1);
-  BN_bin2bn(exp_bin, 4, &bn_exp);
-  BN_bin2bn(mod_bin, mod_size, &bn_mod);
-  BN_mod_exp(&val2, &val1, &bn_exp, &bn_mod, bn_ctx);
-  int output_length = BN_bn2bin(&val2, output);
+  BN_bin2bn(input_temp, length, val1);
+  BN_bin2bn(exp_bin, 4, bn_exp);
+  BN_bin2bn(mod_bin, mod_size, bn_mod);
+  BN_mod_exp(val2, val1, bn_exp, bn_mod, bn_ctx);
+  int output_length = BN_bn2bin(val2, output);
   mem_reverse(output, output_length);
   if (output_length < (int) mod_size)
     memset(output + output_length, 0, mod_size - output_length);
 
   BN_CTX_free(bn_ctx);
-  BN_clear_free(&val1);
-  BN_free(&val2);
-  BN_free(&bn_mod);
-  BN_free(&bn_exp);
+  BN_clear_free(val1);
+  BN_free(val2);
+  BN_free(bn_mod);
+  BN_free(bn_exp);
 
 }
 
diff --git a/modules/ncrack_ssh.cc b/modules/ncrack_ssh.cc
index 959f4d4..038aa53 100644
--- a/modules/ncrack_ssh.cc
+++ b/modules/ncrack_ssh.cc
@@ -577,8 +577,8 @@ ssh_free(Connection *con)
     }
   }
 
-  EVP_CIPHER_CTX_cleanup(&p->receive_context.evp);
-  EVP_CIPHER_CTX_cleanup(&p->send_context.evp);
+  EVP_CIPHER_CTX_free(p->receive_context.evp);
+  EVP_CIPHER_CTX_free(p->send_context.evp);
 
   buffer_free(p->input);
   buffer_free(p->output);
diff --git a/opensshlib/cipher-3des1.c b/opensshlib/cipher-3des1.c
index 6a0f1f3..790faa2 100644
--- a/opensshlib/cipher-3des1.c
+++ b/opensshlib/cipher-3des1.c
@@ -42,7 +42,7 @@
  */
 struct ssh1_3des_ctx
 {
-	EVP_CIPHER_CTX	k1, k2, k3;
+	EVP_CIPHER_CTX	*k1, *k2, *k3;
 };
 
 const EVP_CIPHER * evp_ssh1_3des(void);
@@ -63,7 +63,7 @@ ssh1_3des_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
 	if (key == NULL)
 		return 1;
 	if (enc == -1)
-		enc = ctx->encrypt;
+		enc = EVP_CIPHER_CTX_encrypting(ctx);
 	k1 = k2 = k3 = (u_char *) key;
 	k2 += 8;
 	if (EVP_CIPHER_CTX_key_length(ctx) >= 16+8) {
@@ -72,12 +72,15 @@ ssh1_3des_init(EVP_CIPHER_CTX *ctx, const u_char *key, const u_char *iv,
 		else
 			k1 += 16;
 	}
-	EVP_CIPHER_CTX_init(&c->k1);
-	EVP_CIPHER_CTX_init(&c->k2);
-	EVP_CIPHER_CTX_init(&c->k3);
-	if (EVP_CipherInit(&c->k1, EVP_des_cbc(), k1, NULL, enc) == 0 ||
-	    EVP_CipherInit(&c->k2, EVP_des_cbc(), k2, NULL, !enc) == 0 ||
-	    EVP_CipherInit(&c->k3, EVP_des_cbc(), k3, NULL, enc) == 0) {
+	c->k1 = EVP_CIPHER_CTX_new();
+	c->k2 = EVP_CIPHER_CTX_new();
+	c->k3 = EVP_CIPHER_CTX_new();
+	if (EVP_CipherInit(c->k1, EVP_des_cbc(), k1, NULL, enc) == 0 ||
+	    EVP_CipherInit(c->k2, EVP_des_cbc(), k2, NULL, !enc) == 0 ||
+	    EVP_CipherInit(c->k3, EVP_des_cbc(), k3, NULL, enc) == 0) {
+		EVP_CIPHER_CTX_free(c->k1);
+		EVP_CIPHER_CTX_free(c->k2);
+		EVP_CIPHER_CTX_free(c->k3);
 		explicit_bzero(c, sizeof(*c));
 		free(c);
 		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
@@ -93,9 +96,9 @@ ssh1_3des_cbc(EVP_CIPHER_CTX *ctx, u_char *dest, const u_char *src, size_t len)
 
 	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) == NULL)
 		return 0;
-	if (EVP_Cipher(&c->k1, dest, (u_char *)src, len) == 0 ||
-	    EVP_Cipher(&c->k2, dest, dest, len) == 0 ||
-	    EVP_Cipher(&c->k3, dest, dest, len) == 0)
+	if (EVP_Cipher(c->k1, dest, (u_char *)src, len) == 0 ||
+	    EVP_Cipher(c->k2, dest, dest, len) == 0 ||
+	    EVP_Cipher(c->k3, dest, dest, len) == 0)
 		return 0;
 	return 1;
 }
@@ -106,9 +109,9 @@ ssh1_3des_cleanup(EVP_CIPHER_CTX *ctx)
 	struct ssh1_3des_ctx *c;
 
 	if ((c = EVP_CIPHER_CTX_get_app_data(ctx)) != NULL) {
-		EVP_CIPHER_CTX_cleanup(&c->k1);
-		EVP_CIPHER_CTX_cleanup(&c->k2);
-		EVP_CIPHER_CTX_cleanup(&c->k3);
+		EVP_CIPHER_CTX_free(c->k1);
+		EVP_CIPHER_CTX_free(c->k2);
+		EVP_CIPHER_CTX_free(c->k3);
 		explicit_bzero(c, sizeof(*c));
 		free(c);
 		EVP_CIPHER_CTX_set_app_data(ctx, NULL);
@@ -126,30 +129,29 @@ ssh1_3des_iv(EVP_CIPHER_CTX *evp, int doset, u_char *iv, int len)
 	if ((c = EVP_CIPHER_CTX_get_app_data(evp)) == NULL)
 		return SSH_ERR_INTERNAL_ERROR;
 	if (doset) {
-		memcpy(c->k1.iv, iv, 8);
-		memcpy(c->k2.iv, iv + 8, 8);
-		memcpy(c->k3.iv, iv + 16, 8);
+		// FIXME(hb) Is there a saner way to do this?
+		memcpy(EVP_CIPHER_CTX_iv_noconst(c->k1), iv, 8);
+		memcpy(EVP_CIPHER_CTX_iv_noconst(c->k2), iv + 8, 8);
+		memcpy(EVP_CIPHER_CTX_iv_noconst(c->k3), iv + 16, 8);
 	} else {
-		memcpy(iv, c->k1.iv, 8);
-		memcpy(iv + 8, c->k2.iv, 8);
-		memcpy(iv + 16, c->k3.iv, 8);
+		memcpy(iv, EVP_CIPHER_CTX_iv(c->k1), 8);
+		memcpy(iv + 8, EVP_CIPHER_CTX_iv(c->k2), 8);
+		memcpy(iv + 16, EVP_CIPHER_CTX_iv(c->k3), 8);
 	}
 	return 0;
 }
 
+static EVP_CIPHER *ssh1_3des;
+
 const EVP_CIPHER *
 evp_ssh1_3des(void)
 {
-	static EVP_CIPHER ssh1_3des;
-
-	memset(&ssh1_3des, 0, sizeof(ssh1_3des));
-	ssh1_3des.nid = NID_undef;
-	ssh1_3des.block_size = 8;
-	ssh1_3des.iv_len = 0;
-	ssh1_3des.key_len = 16;
-	ssh1_3des.init = ssh1_3des_init;
-	ssh1_3des.cleanup = ssh1_3des_cleanup;
-	ssh1_3des.do_cipher = ssh1_3des_cbc;
-	ssh1_3des.flags = EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH;
-	return &ssh1_3des;
+	ssh1_3des = EVP_CIPHER_meth_new(NID_undef, 8, 16);
+
+	EVP_CIPHER_meth_set_iv_length(ssh1_3des, 0);
+	EVP_CIPHER_meth_set_init(ssh1_3des, ssh1_3des_init);
+	EVP_CIPHER_meth_set_cleanup(ssh1_3des, ssh1_3des_cleanup);
+	EVP_CIPHER_meth_set_do_cipher(ssh1_3des, ssh1_3des_cbc);
+	EVP_CIPHER_meth_set_flags(ssh1_3des, EVP_CIPH_CBC_MODE | EVP_CIPH_VARIABLE_LENGTH);
+	return ssh1_3des;
 }
diff --git a/opensshlib/cipher-bf1.c b/opensshlib/cipher-bf1.c
index c066310..8e3aac3 100644
--- a/opensshlib/cipher-bf1.c
+++ b/opensshlib/cipher-bf1.c
@@ -70,34 +70,33 @@ static void bf_ssh1_init (EVP_CIPHER_CTX * ctx, const unsigned char *key,
 }
 #endif
 
-static int (*orig_bf)(EVP_CIPHER_CTX *, u_char *,
+static int (*orig_do_cipher)(EVP_CIPHER_CTX *, u_char *,
     const u_char *, LIBCRYPTO_EVP_INL_TYPE) = NULL;
 
 static int
-bf_ssh1_cipher(EVP_CIPHER_CTX *ctx, u_char *out, const u_char *in,
+bf_ssh1_do_cipher(EVP_CIPHER_CTX *ctx, u_char *out, const u_char *in,
     LIBCRYPTO_EVP_INL_TYPE len)
 {
 	int ret;
 
 	swap_bytes(in, out, len);
-	ret = (*orig_bf)(ctx, out, out, len);
+	ret = (*orig_do_cipher)(ctx, out, out, len);
 	swap_bytes(out, out, len);
 	return (ret);
 }
 
+static EVP_CIPHER *ssh1_bf;
+
 const EVP_CIPHER *
 evp_ssh1_bf(void)
 {
-	static EVP_CIPHER ssh1_bf;
-
-	memcpy(&ssh1_bf, EVP_bf_cbc(), sizeof(EVP_CIPHER));
-	orig_bf = ssh1_bf.do_cipher;
-	ssh1_bf.nid = NID_undef;
-#ifdef SSH_OLD_EVP
-	ssh1_bf.init = bf_ssh1_init;
-#endif
-	ssh1_bf.do_cipher = bf_ssh1_cipher;
-	ssh1_bf.key_len = 32;
-	return (&ssh1_bf);
+	ssh1_bf = EVP_CIPHER_meth_dup(EVP_bf_cbc());
+	orig_do_cipher = EVP_CIPHER_meth_get_do_cipher(ssh1_bf);
+	/* FIXME(hb): Do we need to set the associated NID?
+	   (ssh1_bf.nid = NID_undef)
+	   Do we need to set key length? (ssh1_bf.key_len = 32)
+	*/
+	EVP_CIPHER_meth_set_do_cipher(ssh1_bf, bf_ssh1_do_cipher);
+	return (ssh1_bf);
 }
 #endif /* WITH_OPENSSL */
diff --git a/opensshlib/cipher.c b/opensshlib/cipher.c
index feb6828..1d8a359 100644
--- a/opensshlib/cipher.c
+++ b/opensshlib/cipher.c
@@ -330,26 +330,26 @@ cipher_init(struct sshcipher_ctx *cc, const struct sshcipher *cipher,
 	return SSH_ERR_INVALID_ARGUMENT;
 #else
 	type = (*cipher->evptype)();
-	EVP_CIPHER_CTX_init(&cc->evp);
-	if (EVP_CipherInit(&cc->evp, type, NULL, (u_char *)iv,
+	cc->evp = EVP_CIPHER_CTX_new();
+	if (EVP_CipherInit(cc->evp, type, NULL, (u_char *)iv,
 	    (do_encrypt == CIPHER_ENCRYPT)) == 0) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto bad;
 	}
 	if (cipher_authlen(cipher) &&
-	    !EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,
+	    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_IV_FIXED,
 	    -1, (u_char *)iv)) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto bad;
 	}
-	klen = EVP_CIPHER_CTX_key_length(&cc->evp);
+	klen = EVP_CIPHER_CTX_key_length(cc->evp);
 	if (klen > 0 && keylen != (u_int)klen) {
-		if (EVP_CIPHER_CTX_set_key_length(&cc->evp, keylen) == 0) {
+		if (EVP_CIPHER_CTX_set_key_length(cc->evp, keylen) == 0) {
 			ret = SSH_ERR_LIBCRYPTO_ERROR;
 			goto bad;
 		}
 	}
-	if (EVP_CipherInit(&cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {
+	if (EVP_CipherInit(cc->evp, NULL, (u_char *)key, NULL, -1) == 0) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto bad;
 	}
@@ -362,14 +362,14 @@ cipher_init(struct sshcipher_ctx *cc, const struct sshcipher *cipher,
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto bad;
 		}
-		ret = EVP_Cipher(&cc->evp, discard, junk, cipher->discard_len);
+		ret = EVP_Cipher(cc->evp, discard, junk, cipher->discard_len);
 		explicit_bzero(discard, cipher->discard_len);
 		free(junk);
 		free(discard);
 		if (ret != 1) {
 			ret = SSH_ERR_LIBCRYPTO_ERROR;
  bad:
-			EVP_CIPHER_CTX_cleanup(&cc->evp);
+			EVP_CIPHER_CTX_free(cc->evp);
 			return ret;
 		}
 	}
@@ -415,33 +415,33 @@ cipher_crypt(struct sshcipher_ctx *cc, u_int seqnr, u_char *dest,
 		if (authlen != cipher_authlen(cc->cipher))
 			return SSH_ERR_INVALID_ARGUMENT;
 		/* increment IV */
-		if (!EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_IV_GEN,
+		if (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,
 		    1, lastiv))
 			return SSH_ERR_LIBCRYPTO_ERROR;
 		/* set tag on decyption */
 		if (!cc->encrypt &&
-		    !EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_SET_TAG,
+		    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_SET_TAG,
 		    authlen, (u_char *)src + aadlen + len))
 			return SSH_ERR_LIBCRYPTO_ERROR;
 	}
 	if (aadlen) {
 		if (authlen &&
-		    EVP_Cipher(&cc->evp, NULL, (u_char *)src, aadlen) < 0)
+		    EVP_Cipher(cc->evp, NULL, (u_char *)src, aadlen) < 0)
 			return SSH_ERR_LIBCRYPTO_ERROR;
 		memcpy(dest, src, aadlen);
 	}
 	if (len % cc->cipher->block_size)
 		return SSH_ERR_INVALID_ARGUMENT;
-	if (EVP_Cipher(&cc->evp, dest + aadlen, (u_char *)src + aadlen,
+	if (EVP_Cipher(cc->evp, dest + aadlen, (u_char *)src + aadlen,
 	    len) < 0)
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	if (authlen) {
 		/* compute tag (on encrypt) or verify tag (on decrypt) */
-		if (EVP_Cipher(&cc->evp, NULL, NULL, 0) < 0)
+		if (EVP_Cipher(cc->evp, NULL, NULL, 0) < 0)
 			return cc->encrypt ?
 			    SSH_ERR_LIBCRYPTO_ERROR : SSH_ERR_MAC_INVALID;
 		if (cc->encrypt &&
-		    !EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_GET_TAG,
+		    !EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_GET_TAG,
 		    authlen, dest + aadlen + len))
 			return SSH_ERR_LIBCRYPTO_ERROR;
 	}
@@ -473,8 +473,7 @@ cipher_cleanup(struct sshcipher_ctx *cc)
 	else if ((cc->cipher->flags & CFLAG_AESCTR) != 0)
 		explicit_bzero(&cc->ac_ctx, sizeof(cc->ac_ctx));
 #ifdef WITH_OPENSSL
-	else if (EVP_CIPHER_CTX_cleanup(&cc->evp) == 0)
-		return SSH_ERR_LIBCRYPTO_ERROR;
+	EVP_CIPHER_CTX_free(cc->evp);
 #endif
 	return 0;
 }
@@ -520,7 +519,7 @@ cipher_get_keyiv_len(const struct sshcipher_ctx *cc)
 		ivlen = sizeof(cc->ac_ctx.ctr);
 #ifdef WITH_OPENSSL
 	else
-		ivlen = EVP_CIPHER_CTX_iv_length(&cc->evp);
+		ivlen = EVP_CIPHER_CTX_iv_length(cc->evp);
 #endif /* WITH_OPENSSL */
 	return (ivlen);
 }
@@ -552,7 +551,7 @@ cipher_get_keyiv(struct sshcipher_ctx *cc, u_char *iv, u_int len)
 	case SSH_CIPHER_SSH2:
 	case SSH_CIPHER_DES:
 	case SSH_CIPHER_BLOWFISH:
-		evplen = EVP_CIPHER_CTX_iv_length(&cc->evp);
+		evplen = EVP_CIPHER_CTX_iv_length(cc->evp);
 		if (evplen == 0)
 			return 0;
 		else if (evplen < 0)
@@ -561,20 +560,20 @@ cipher_get_keyiv(struct sshcipher_ctx *cc, u_char *iv, u_int len)
 			return SSH_ERR_INVALID_ARGUMENT;
 #ifndef OPENSSL_HAVE_EVPCTR
 		if (c->evptype == evp_aes_128_ctr)
-			ssh_aes_ctr_iv(&cc->evp, 0, iv, len);
+			ssh_aes_ctr_iv(cc->evp, 0, iv, len);
 		else
 #endif
 		if (cipher_authlen(c)) {
-			if (!EVP_CIPHER_CTX_ctrl(&cc->evp, EVP_CTRL_GCM_IV_GEN,
+			if (!EVP_CIPHER_CTX_ctrl(cc->evp, EVP_CTRL_GCM_IV_GEN,
 			   len, iv))
 			       return SSH_ERR_LIBCRYPTO_ERROR;
 		} else
-			memcpy(iv, cc->evp.iv, len);
+			memcpy(iv, EVP_CIPHER_CTX_iv(cc->evp), len);
 		break;
 #endif
 #ifdef WITH_SSH1
 	case SSH_CIPHER_3DES:
-		return ssh1_3des_iv(&cc->evp, 0, iv, 24);
+		return ssh1_3des_iv(cc->evp, 0, iv, 24);
 #endif
 	default:
 		return SSH_ERR_INVALID_ARGUMENT;
@@ -600,21 +599,25 @@ cipher_set_keyiv(struct sshcipher_ctx *cc, const u_char *iv)
 	case SSH_CIPHER_SSH2:
 	case SSH_CIPHER_DES:
 	case SSH_CIPHER_BLOWFISH:
-		evplen = EVP_CIPHER_CTX_iv_length(&cc->evp);
+		evplen = EVP_CIPHER_CTX_iv_length(cc->evp);
 		if (evplen <= 0)
 			return SSH_ERR_LIBCRYPTO_ERROR;
 		if (cipher_authlen(c)) {
 			/* XXX iv arg is const, but EVP_CIPHER_CTX_ctrl isn't */
-			if (!EVP_CIPHER_CTX_ctrl(&cc->evp,
+			if (!EVP_CIPHER_CTX_ctrl(cc->evp,
 			    EVP_CTRL_GCM_SET_IV_FIXED, -1, (void *)iv))
 				return SSH_ERR_LIBCRYPTO_ERROR;
-		} else
-			memcpy(cc->evp.iv, iv, evplen);
+		} else {
+			/* XXX There must be a saner way to do this
+			   than using the "getter" function to determine
+			   the target of a copy operation */
+			memcpy(EVP_CIPHER_CTX_iv_noconst(cc->evp), iv, evplen);
+		}
 		break;
 #endif
 #ifdef WITH_SSH1
 	case SSH_CIPHER_3DES:
-		return ssh1_3des_iv(&cc->evp, 1, (u_char *)iv, 24);
+		return ssh1_3des_iv(cc->evp, 1, (u_char *)iv, 24);
 #endif
 	default:
 		return SSH_ERR_INVALID_ARGUMENT;
@@ -623,8 +626,8 @@ cipher_set_keyiv(struct sshcipher_ctx *cc, const u_char *iv)
 }
 
 #ifdef WITH_OPENSSL
-#define EVP_X_STATE(evp)	(evp).cipher_data
-#define EVP_X_STATE_LEN(evp)	(evp).cipher->ctx_size
+#define EVP_X_STATE(evp)	EVP_CIPHER_CTX_get_cipher_data(evp)
+#define EVP_X_STATE_LEN(evp)	EVP_CIPHER_impl_ctx_size(EVP_CIPHER_CTX_cipher(evp))
 #endif
 
 int
diff --git a/opensshlib/cipher.h b/opensshlib/cipher.h
index 06d4be4..5029bd7 100644
--- a/opensshlib/cipher.h
+++ b/opensshlib/cipher.h
@@ -66,7 +66,7 @@ struct sshcipher;
 struct sshcipher_ctx {
 	int	plaintext;
 	int	encrypt;
-	EVP_CIPHER_CTX evp;
+	EVP_CIPHER_CTX *evp;
 	struct chachapoly_ctx cp_ctx; /* XXX union with evp? */
 	struct aesctr_ctx ac_ctx; /* XXX union with evp? */
 	const struct sshcipher *cipher;
diff --git a/opensshlib/dh.c b/opensshlib/dh.c
index 7eb8282..3c7ad1a 100644
--- a/opensshlib/dh.c
+++ b/opensshlib/dh.c
@@ -215,14 +215,15 @@ choose_dh(int min, int wantbits, int max)
 /* diffie-hellman-groupN-sha1 */
 
 int
-dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
+dh_pub_is_valid(DH *dh, const BIGNUM *dh_pub)
 {
 	int i;
 	int n = BN_num_bits(dh_pub);
 	int bits_set = 0;
 	BIGNUM *tmp;
+	const BIGNUM *dh_p;
 
-	if (dh_pub->neg) {
+	if (BN_is_negative(dh_pub)) {
 		logit("invalid public DH value: negative");
 		return 0;
 	}
@@ -235,7 +236,9 @@ dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
 		ssh_error("%s: BN_new failed", __func__);
 		return 0;
 	}
-	if (!BN_sub(tmp, dh->p, BN_value_one()) ||
+
+	DH_get0_pqg(dh, &dh_p, NULL, NULL);
+	if (!BN_sub(tmp, dh_p, BN_value_one()) ||
 	    BN_cmp(dh_pub, tmp) != -1) {		/* pub_exp > p-2 */
 		BN_clear_free(tmp);
 		logit("invalid public DH value: >= p-1");
@@ -246,13 +249,13 @@ dh_pub_is_valid(DH *dh, BIGNUM *dh_pub)
 	for (i = 0; i <= n; i++)
 		if (BN_is_bit_set(dh_pub, i))
 			bits_set++;
-	debug2("bits set: %d/%d", bits_set, BN_num_bits(dh->p));
+	debug2("bits set: %d/%d", bits_set, BN_num_bits(dh_p));
 
 	/* if g==2 and bits_set==1 then computing log_g(dh_pub) is trivial */
 	if (bits_set > 1)
 		return 1;
 
-	logit("invalid public DH value (%d/%d)", bits_set, BN_num_bits(dh->p));
+	logit("invalid public DH value (%d/%d)", bits_set, BN_num_bits(dh_p));
 	return 0;
 }
 
@@ -260,15 +263,17 @@ int
 dh_gen_key(DH *dh, int need)
 {
 	int pbits;
+	const BIGNUM *dh_p, *dh_pub_key;
+	DH_get0_pqg(dh, &dh_p, NULL, NULL);
 
-	if (need < 0 || dh->p == NULL ||
-	    (pbits = BN_num_bits(dh->p)) <= 0 ||
+	if (need < 0 || dh_p == NULL ||
+	    (pbits = BN_num_bits(dh_p)) <= 0 ||
 	    need > INT_MAX / 2 || 2 * need > pbits)
 		return SSH_ERR_INVALID_ARGUMENT;
-	dh->length = MIN(need * 2, pbits - 1);
+	DH_set_length(dh, MIN(need * 2, pbits - 1));
+	DH_get0_key(dh, &dh_pub_key, NULL);
 	if (DH_generate_key(dh) == 0 ||
-	    !dh_pub_is_valid(dh, dh->pub_key)) {
-		BN_clear_free(dh->priv_key);
+	    !dh_pub_is_valid(dh, dh_pub_key)) {
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	}
 	return 0;
@@ -278,11 +283,13 @@ DH *
 dh_new_group_asc(const char *gen, const char *modulus)
 {
 	DH *dh;
+	const BIGNUM *dh_p, *dh_g;
 
 	if ((dh = DH_new()) == NULL)
 		return NULL;
-	if (BN_hex2bn(&dh->p, modulus) == 0 ||
-	    BN_hex2bn(&dh->g, gen) == 0) {
+	DH_get0_pqg(dh, &dh_p, NULL, &dh_g);
+	if (BN_hex2bn((BIGNUM**)&dh_p, modulus) == 0 ||
+	    BN_hex2bn((BIGNUM**)&dh_g, gen) == 0) {
 		DH_free(dh);
 		return NULL;
 	}
@@ -301,8 +308,7 @@ dh_new_group(BIGNUM *gen, BIGNUM *modulus)
 
 	if ((dh = DH_new()) == NULL)
 		return NULL;
-	dh->p = modulus;
-	dh->g = gen;
+	DH_set0_pqg(dh, modulus, NULL, gen);
 
 	return (dh);
 }
diff --git a/opensshlib/dh.h b/opensshlib/dh.h
index 6546953..8533cc6 100644
--- a/opensshlib/dh.h
+++ b/opensshlib/dh.h
@@ -40,7 +40,7 @@ DH	*dh_new_group14(void);
 DH	*dh_new_group_fallback(int);
 
 int	 dh_gen_key(DH *, int);
-int	 dh_pub_is_valid(DH *, BIGNUM *);
+int	 dh_pub_is_valid(DH *, const BIGNUM *);
 
 u_int	 dh_estimate(int);
 
diff --git a/opensshlib/digest-openssl.c b/opensshlib/digest-openssl.c
index df5292a..6612887 100644
--- a/opensshlib/digest-openssl.c
+++ b/opensshlib/digest-openssl.c
@@ -43,7 +43,7 @@
 
 struct ssh_digest_ctx {
 	int alg;
-	EVP_MD_CTX mdctx;
+	EVP_MD_CTX *mdctx;
 };
 
 struct ssh_digest {
@@ -111,7 +111,7 @@ ssh_digest_bytes(int alg)
 size_t
 ssh_digest_blocksize(struct ssh_digest_ctx *ctx)
 {
-	return EVP_MD_CTX_block_size(&ctx->mdctx);
+	return EVP_MD_CTX_block_size(ctx->mdctx);
 }
 
 struct ssh_digest_ctx *
@@ -123,8 +123,9 @@ ssh_digest_start(int alg)
 	if (digest == NULL || ((ret = calloc(1, sizeof(*ret))) == NULL))
 		return NULL;
 	ret->alg = alg;
-	EVP_MD_CTX_init(&ret->mdctx);
-	if (EVP_DigestInit_ex(&ret->mdctx, digest->mdfunc(), NULL) != 1) {
+	ret->mdctx = EVP_MD_CTX_new();
+	if (EVP_DigestInit_ex(ret->mdctx, digest->mdfunc(), NULL) != 1) {
+		EVP_MD_CTX_free(ret->mdctx);
 		free(ret);
 		return NULL;
 	}
@@ -137,7 +138,7 @@ ssh_digest_copy_state(struct ssh_digest_ctx *from, struct ssh_digest_ctx *to)
 	if (from->alg != to->alg)
 		return SSH_ERR_INVALID_ARGUMENT;
 	/* we have bcopy-style order while openssl has memcpy-style */
-	if (!EVP_MD_CTX_copy_ex(&to->mdctx, &from->mdctx))
+	if (!EVP_MD_CTX_copy_ex(to->mdctx, from->mdctx))
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	return 0;
 }
@@ -145,7 +146,7 @@ ssh_digest_copy_state(struct ssh_digest_ctx *from, struct ssh_digest_ctx *to)
 int
 ssh_digest_update(struct ssh_digest_ctx *ctx, const void *m, size_t mlen)
 {
-	if (EVP_DigestUpdate(&ctx->mdctx, m, mlen) != 1)
+	if (EVP_DigestUpdate(ctx->mdctx, m, mlen) != 1)
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	return 0;
 }
@@ -166,7 +167,7 @@ ssh_digest_final(struct ssh_digest_ctx *ctx, u_char *d, size_t dlen)
 		return SSH_ERR_INVALID_ARGUMENT;
 	if (dlen < digest->digest_len) /* No truncation allowed */
 		return SSH_ERR_INVALID_ARGUMENT;
-	if (EVP_DigestFinal_ex(&ctx->mdctx, d, &l) != 1)
+	if (EVP_DigestFinal_ex(ctx->mdctx, d, &l) != 1)
 		return SSH_ERR_LIBCRYPTO_ERROR;
 	if (l != digest->digest_len) /* sanity */
 		return SSH_ERR_INTERNAL_ERROR;
@@ -177,7 +178,7 @@ void
 ssh_digest_free(struct ssh_digest_ctx *ctx)
 {
 	if (ctx != NULL) {
-		EVP_MD_CTX_cleanup(&ctx->mdctx);
+		EVP_MD_CTX_free(ctx->mdctx);
 		explicit_bzero(ctx, sizeof(*ctx));
 		free(ctx);
 	}
diff --git a/opensshlib/kexdhc.c b/opensshlib/kexdhc.c
index 2ce6eef..cf5e04c 100644
--- a/opensshlib/kexdhc.c
+++ b/opensshlib/kexdhc.c
@@ -56,6 +56,7 @@ kexdh_client(ncrack_ssh_state *nstate)
 {
 	struct kex *kex = nstate->kex;
 	int r;
+	const BIGNUM *kex_dh_pub_key;
 
   //printf("kexdh client\n");
 
@@ -76,15 +77,16 @@ kexdh_client(ncrack_ssh_state *nstate)
 		goto out;
 	}
 	debug("sending SSH2_MSG_KEXDH_INIT");
+	DH_get0_key(kex->dh, &kex_dh_pub_key, NULL);
 	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0 ||
 	    (r = sshpkt_start(nstate, SSH2_MSG_KEXDH_INIT)) != 0 ||
-	    (r = sshpkt_put_bignum2(nstate, kex->dh->pub_key)) != 0 ||
+	    (r = sshpkt_put_bignum2(nstate, kex_dh_pub_key)) != 0 ||
 	    (r = sshpkt_send(nstate)) != 0)
 		goto out;
 #ifdef DEBUG_KEXDH
 	DHparams_print_fp(stderr, kex->dh);
 	fprintf(stderr, "pub= ");
-	BN_print_fp(stderr, kex->dh->pub_key);
+	BN_print_fp(stderr, kex_dh_pub_key);
 	fprintf(stderr, "\n");
 #endif
 	debug("expecting SSH2_MSG_KEXDH_REPLY");
@@ -105,6 +107,7 @@ ncrackssh_input_kex_dh(ncrack_ssh_state *nstate)
 	u_char hash[SSH_DIGEST_MAX_LENGTH];
 	size_t klen = 0, slen, sbloblen, hashlen;
 	int kout, r;
+	const BIGNUM *kex_dh_pub_key;
 
 	if (kex->verify_host_key == NULL) {
 		r = SSH_ERR_INVALID_ARGUMENT;
@@ -163,6 +166,8 @@ ncrackssh_input_kex_dh(ncrack_ssh_state *nstate)
 	dump_digest("shared secret", kbuf, kout);
 #endif
 
+	DH_get0_key(kex->dh, &kex_dh_pub_key, NULL);
+
 	/* calc and verify H */
 	hashlen = sizeof(hash);
 	if ((r = kex_dh_hash(
@@ -171,7 +176,7 @@ ncrackssh_input_kex_dh(ncrack_ssh_state *nstate)
 	    sshbuf_ptr(kex->my), sshbuf_len(kex->my),
 	    sshbuf_ptr(kex->peer), sshbuf_len(kex->peer),
 	    server_host_key_blob, sbloblen,
-	    kex->dh->pub_key,
+	    kex_dh_pub_key,
 	    dh_server_pub,
 	    shared_secret,
 	    hash, &hashlen)) != 0)
diff --git a/opensshlib/kexgexc.c b/opensshlib/kexgexc.c
index 5eb6e66..ba82634 100644
--- a/opensshlib/kexgexc.c
+++ b/opensshlib/kexgexc.c
@@ -100,6 +100,7 @@ ncrackssh_input_kex_dh_gex_group(ncrack_ssh_state *nstate)
 	struct kex *kex = nstate->kex;
 	BIGNUM *p = NULL, *g = NULL;
 	int r, bits;
+	const BIGNUM *kex_dh_pub_key;
 
   //printf("DH GEX GROUP\n");
 
@@ -124,18 +125,19 @@ ncrackssh_input_kex_dh_gex_group(ncrack_ssh_state *nstate)
 		goto out;
 	}
 	p = g = NULL; /* belong to kex->dh now */
+	DH_get0_key(kex->dh, &kex_dh_pub_key, NULL);
 
 	/* generate and send 'e', client DH public key */
 	if ((r = dh_gen_key(kex->dh, kex->we_need * 8)) != 0 ||
 	    (r = sshpkt_start(nstate, SSH2_MSG_KEX_DH_GEX_INIT)) != 0 ||
-	    (r = sshpkt_put_bignum2(nstate, kex->dh->pub_key)) != 0 ||
+	    (r = sshpkt_put_bignum2(nstate, kex_dh_pub_key)) != 0 ||
 	    (r = sshpkt_send(nstate)) != 0)
 		goto out;
 	debug("SSH2_MSG_KEX_DH_GEX_INIT sent");
 #ifdef DEBUG_KEXDH
 	DHparams_print_fp(stderr, kex->dh);
 	fprintf(stderr, "pub= ");
-	BN_print_fp(stderr, kex->dh->pub_key);
+	BN_print_fp(stderr, kex_dh_pub_key);
 	fprintf(stderr, "\n");
 #endif
 
@@ -161,6 +163,7 @@ ncrackssh_input_kex_dh_gex_reply(ncrack_ssh_state *nstate)
 	u_char hash[SSH_DIGEST_MAX_LENGTH];
 	size_t klen = 0, slen, sbloblen, hashlen;
 	int kout, r;
+	const BIGNUM *kex_dh_pub_key, *kex_dh_p, *kex_dh_g;
 
 	debug("got SSH2_MSG_KEX_DH_GEX_REPLY");
 	if (kex->verify_host_key == NULL) {
@@ -225,6 +228,8 @@ ncrackssh_input_kex_dh_gex_reply(ncrack_ssh_state *nstate)
 #endif
 	if (nstate->compat & SSH_OLD_DHGEX)
 		kex->min = kex->max = -1;
+	DH_get0_key(kex->dh, &kex_dh_pub_key, NULL);
+	DH_get0_pqg(kex->dh, &kex_dh_p, NULL, &kex_dh_g);
 
 	/* calc and verify H */
 	hashlen = sizeof(hash);
@@ -236,8 +241,8 @@ ncrackssh_input_kex_dh_gex_reply(ncrack_ssh_state *nstate)
 	    sshbuf_ptr(kex->peer), sshbuf_len(kex->peer),
 	    server_host_key_blob, sbloblen,
 	    kex->min, kex->nbits, kex->max,
-	    kex->dh->p, kex->dh->g,
-	    kex->dh->pub_key,
+	    kex_dh_p, kex_dh_g,
+	    kex_dh_pub_key,
 	    dh_server_pub,
 	    shared_secret,
 	    hash, &hashlen)) != 0)
diff --git a/opensshlib/rsa.c b/opensshlib/rsa.c
index 5ecacef..1d0178a 100644
--- a/opensshlib/rsa.c
+++ b/opensshlib/rsa.c
@@ -77,10 +77,13 @@ rsa_public_encrypt(BIGNUM *out, BIGNUM *in, RSA *key)
 	u_char *inbuf = NULL, *outbuf = NULL;
 	int len, ilen, olen, r = SSH_ERR_INTERNAL_ERROR;
 
-	if (BN_num_bits(key->e) < 2 || !BN_is_odd(key->e))
+	const BIGNUM *key_n, *key_e, *key_d;
+	RSA_get0_key(key, &key_n, &key_e, &key_d);
+
+	if (BN_num_bits(key_e) < 2 || !BN_is_odd(key_e))
 		return SSH_ERR_INVALID_ARGUMENT;
 
-	olen = BN_num_bytes(key->n);
+	olen = BN_num_bytes(key_n);
 	if ((outbuf = malloc(olen)) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
@@ -123,7 +126,10 @@ rsa_private_decrypt(BIGNUM *out, BIGNUM *in, RSA *key)
 	u_char *inbuf = NULL, *outbuf = NULL;
 	int len, ilen, olen, r = SSH_ERR_INTERNAL_ERROR;
 
-	olen = BN_num_bytes(key->n);
+	const BIGNUM *key_n, *key_e, *key_d;
+	RSA_get0_key(key, &key_n, &key_e, &key_d);
+
+	olen = BN_num_bytes(key_n);
 	if ((outbuf = malloc(olen)) == NULL) {
 		r = SSH_ERR_ALLOC_FAIL;
 		goto out;
@@ -165,6 +171,12 @@ rsa_generate_additional_parameters(RSA *rsa)
 	BN_CTX *ctx = NULL;
 	int r;
 
+	BIGNUM *rsa_d, *rsa_p, *rsa_q;
+	BIGNUM *rsa_dmp1, *rsa_dmq1;
+	RSA_get0_key(rsa, NULL, NULL, (const BIGNUM**)&rsa_d);
+	RSA_get0_factors(rsa, (const BIGNUM**)&rsa_p, (const BIGNUM**)&rsa_q);
+	RSA_get0_crt_params(rsa, (const BIGNUM**)&rsa_dmp1, (const BIGNUM**)&rsa_dmq1, NULL);
+
 	if ((ctx = BN_CTX_new()) == NULL)
 		return SSH_ERR_ALLOC_FAIL;
 	if ((aux = BN_new()) == NULL) {
@@ -172,10 +184,10 @@ rsa_generate_additional_parameters(RSA *rsa)
 		goto out;
 	}
 
-	if ((BN_sub(aux, rsa->q, BN_value_one()) == 0) ||
-	    (BN_mod(rsa->dmq1, rsa->d, aux, ctx) == 0) ||
-	    (BN_sub(aux, rsa->p, BN_value_one()) == 0) ||
-	    (BN_mod(rsa->dmp1, rsa->d, aux, ctx) == 0)) {
+	if ((BN_sub(aux, rsa_q, BN_value_one()) == 0) ||
+	    (BN_mod(rsa_dmq1, rsa_d, aux, ctx) == 0) ||
+	    (BN_sub(aux, rsa_p, BN_value_one()) == 0) ||
+	    (BN_mod(rsa_dmp1, rsa_d, aux, ctx) == 0)) {
 		r = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
diff --git a/opensshlib/ssh-dss.c b/opensshlib/ssh-dss.c
index 8ed19d8..2eb49bb 100644
--- a/opensshlib/ssh-dss.c
+++ b/opensshlib/ssh-dss.c
@@ -51,6 +51,8 @@ ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
     const u_char *data, size_t datalen, u_int compat)
 {
 	DSA_SIG *sig = NULL;
+	const BIGNUM *sig_r, *sig_s;
+
 	u_char digest[SSH_DIGEST_MAX_LENGTH], sigblob[SIGBLOB_LEN];
 	size_t rlen, slen, len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
 	struct sshbuf *b = NULL;
@@ -76,15 +78,16 @@ ssh_dss_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 		goto out;
 	}
 
-	rlen = BN_num_bytes(sig->r);
-	slen = BN_num_bytes(sig->s);
+	DSA_SIG_get0(sig, &sig_r, &sig_s);
+	rlen = BN_num_bytes(sig_r);
+	slen = BN_num_bytes(sig_s);
 	if (rlen > INTBLOB_LEN || slen > INTBLOB_LEN) {
 		ret = SSH_ERR_INTERNAL_ERROR;
 		goto out;
 	}
 	explicit_bzero(sigblob, SIGBLOB_LEN);
-	BN_bn2bin(sig->r, sigblob + SIGBLOB_LEN - INTBLOB_LEN - rlen);
-	BN_bn2bin(sig->s, sigblob + SIGBLOB_LEN - slen);
+	BN_bn2bin(sig_r, sigblob + SIGBLOB_LEN - INTBLOB_LEN - rlen);
+	BN_bn2bin(sig_s, sigblob + SIGBLOB_LEN - slen);
 
 	if (compat & SSH_BUG_SIGBLOB) {
 		if (sigp != NULL) {
@@ -133,6 +136,8 @@ ssh_dss_verify(const struct sshkey *key,
     const u_char *data, size_t datalen, u_int compat)
 {
 	DSA_SIG *sig = NULL;
+	const BIGNUM *sig_r, *sig_s;
+
 	u_char digest[SSH_DIGEST_MAX_LENGTH], *sigblob = NULL;
 	size_t len, dlen = ssh_digest_bytes(SSH_DIGEST_SHA1);
 	int ret = SSH_ERR_INTERNAL_ERROR;
@@ -175,15 +180,21 @@ ssh_dss_verify(const struct sshkey *key,
 		goto out;
 	}
 
+	if ((sig = DSA_SIG_new()) == NULL) {
+		ret = SSH_ERR_ALLOC_FAIL;
+		goto out;
+	}
+
+	DSA_SIG_get0(sig, &sig_r, &sig_s);
+
 	/* parse signature */
-	if ((sig = DSA_SIG_new()) == NULL ||
-	    (sig->r = BN_new()) == NULL ||
-	    (sig->s = BN_new()) == NULL) {
+	if ((sig_r = BN_new()) == NULL ||
+	    (sig_s = BN_new()) == NULL) {
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if ((BN_bin2bn(sigblob, INTBLOB_LEN, sig->r) == NULL) ||
-	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, sig->s) == NULL)) {
+	if ((BN_bin2bn(sigblob, INTBLOB_LEN, (BIGNUM*)sig_r) == NULL) ||
+	    (BN_bin2bn(sigblob+ INTBLOB_LEN, INTBLOB_LEN, (BIGNUM*)sig_s) == NULL)) {
 		ret = SSH_ERR_LIBCRYPTO_ERROR;
 		goto out;
 	}
diff --git a/opensshlib/ssh-ecdsa.c b/opensshlib/ssh-ecdsa.c
index 2c76f8b..87b5c84 100644
--- a/opensshlib/ssh-ecdsa.c
+++ b/opensshlib/ssh-ecdsa.c
@@ -54,6 +54,7 @@ ssh_ecdsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 	size_t len, dlen;
 	struct sshbuf *b = NULL, *bb = NULL;
 	int ret = SSH_ERR_INTERNAL_ERROR;
+	const BIGNUM *r, *s;
 
 	if (lenp != NULL)
 		*lenp = 0;
@@ -80,8 +81,9 @@ ssh_ecdsa_sign(const struct sshkey *key, u_char **sigp, size_t *lenp,
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if ((ret = sshbuf_put_bignum2(bb, sig->r)) != 0 ||
-	    (ret = sshbuf_put_bignum2(bb, sig->s)) != 0)
+	ECDSA_SIG_get0(sig, &r, &s);
+	if ((ret = sshbuf_put_bignum2(bb, r)) != 0 ||
+	    (ret = sshbuf_put_bignum2(bb, s)) != 0)
 		goto out;
 	if ((ret = sshbuf_put_cstring(b, sshkey_ssh_name_plain(key))) != 0 ||
 	    (ret = sshbuf_put_stringb(b, bb)) != 0)
@@ -121,6 +123,7 @@ ssh_ecdsa_verify(const struct sshkey *key,
 	int ret = SSH_ERR_INTERNAL_ERROR;
 	struct sshbuf *b = NULL, *sigbuf = NULL;
 	char *ktype = NULL;
+	BIGNUM *r = BN_new(), *s = BN_new();
 
 	if (key == NULL || key->ecdsa == NULL ||
 	    sshkey_type_plain(key->type) != KEY_ECDSA)
@@ -152,11 +155,12 @@ ssh_ecdsa_verify(const struct sshkey *key,
 		ret = SSH_ERR_ALLOC_FAIL;
 		goto out;
 	}
-	if (sshbuf_get_bignum2(sigbuf, sig->r) != 0 ||
-	    sshbuf_get_bignum2(sigbuf, sig->s) != 0) {
+	if (sshbuf_get_bignum2(sigbuf, r) != 0 ||
+	    sshbuf_get_bignum2(sigbuf, s) != 0) {
 		ret = SSH_ERR_INVALID_FORMAT;
 		goto out;
 	}
+	ECDSA_SIG_set0(sig, r, s);
 	if (sshbuf_len(sigbuf) != 0) {
 		ret = SSH_ERR_UNEXPECTED_TRAILING_DATA;
 		goto out;
diff --git a/opensshlib/ssh-rsa.c b/opensshlib/ssh-rsa.c
index cdc18a4..69f079c 100644
--- a/opensshlib/ssh-rsa.c
+++ b/opensshlib/ssh-rsa.c
@@ -126,10 +126,15 @@ ssh_rsa_verify(const struct sshkey *key,
 	size_t len, diff, modlen, dlen;
 	struct sshbuf *b = NULL;
 	u_char digest[SSH_DIGEST_MAX_LENGTH], *osigblob, *sigblob = NULL;
+	const BIGNUM* rsa_n;
 
 	if (key == NULL || key->rsa == NULL ||
-	    sshkey_type_plain(key->type) != KEY_RSA ||
-	    BN_num_bits(key->rsa->n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
+	    sshkey_type_plain(key->type) != KEY_RSA)
+		return SSH_ERR_INVALID_ARGUMENT;
+
+	RSA_get0_key(key->rsa, &rsa_n, NULL, NULL);
+
+	if (BN_num_bits(rsa_n) < SSH_RSA_MINIMUM_MODULUS_SIZE)
 		return SSH_ERR_INVALID_ARGUMENT;
 
 	if ((b = sshbuf_from(signature, signaturelen)) == NULL)
diff --git a/opensshlib/sshkey.c b/opensshlib/sshkey.c
index 2c46dfc..ef755d0 100644
--- a/opensshlib/sshkey.c
+++ b/opensshlib/sshkey.c
@@ -273,15 +273,19 @@ sshkey_names_valid2(const char *names, int allow_wildcard)
 u_int
 sshkey_size(const struct sshkey *k)
 {
+	const BIGNUM *n;
+
 	switch (k->type) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA1:
 	case KEY_RSA:
 	case KEY_RSA_CERT:
-		return BN_num_bits(k->rsa->n);
+		RSA_get0_key(k->rsa, &n, NULL, NULL);
+		return BN_num_bits(n);
 	case KEY_DSA:
 	case KEY_DSA_CERT:
-		return BN_num_bits(k->dsa->p);
+		DSA_get0_key(k->dsa, &n, NULL);
+		return BN_num_bits(n);
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
 		return sshkey_curve_nid_to_bits(k->ecdsa_nid);
@@ -470,6 +474,7 @@ sshkey_new(int type)
 #ifdef WITH_OPENSSL
 	RSA *rsa;
 	DSA *dsa;
+	BIGNUM *n, *e, *p, *q, *g, *pub_key;
 #endif /* WITH_OPENSSL */
 
 	if ((k = calloc(1, sizeof(*k))) == NULL)
@@ -487,9 +492,11 @@ sshkey_new(int type)
 	case KEY_RSA1:
 	case KEY_RSA:
 	case KEY_RSA_CERT:
+
 		if ((rsa = RSA_new()) == NULL ||
-		    (rsa->n = BN_new()) == NULL ||
-		    (rsa->e = BN_new()) == NULL) {
+		    (n = BN_new()) == NULL ||
+		    (e = BN_new()) == NULL ||
+		    RSA_set0_key(rsa, n, e, NULL) == 0) {
 			if (rsa != NULL)
 				RSA_free(rsa);
 			free(k);
@@ -500,10 +507,12 @@ sshkey_new(int type)
 	case KEY_DSA:
 	case KEY_DSA_CERT:
 		if ((dsa = DSA_new()) == NULL ||
-		    (dsa->p = BN_new()) == NULL ||
-		    (dsa->q = BN_new()) == NULL ||
-		    (dsa->g = BN_new()) == NULL ||
-		    (dsa->pub_key = BN_new()) == NULL) {
+		    (p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (g = BN_new()) == NULL ||
+		    (pub_key = BN_new()) == NULL ||
+		    DSA_set0_pqg(dsa, p, q, g) == 0 ||
+		    DSA_set0_key(dsa, pub_key, NULL) == 0) {
 			if (dsa != NULL)
 				DSA_free(dsa);
 			free(k);
@@ -546,21 +555,16 @@ sshkey_add_private(struct sshkey *k)
 	case KEY_RSA1:
 	case KEY_RSA:
 	case KEY_RSA_CERT:
-#define bn_maybe_alloc_failed(p) (p == NULL && (p = BN_new()) == NULL)
-		if (bn_maybe_alloc_failed(k->rsa->d) ||
-		    bn_maybe_alloc_failed(k->rsa->iqmp) ||
-		    bn_maybe_alloc_failed(k->rsa->q) ||
-		    bn_maybe_alloc_failed(k->rsa->p) ||
-		    bn_maybe_alloc_failed(k->rsa->dmq1) ||
-		    bn_maybe_alloc_failed(k->rsa->dmp1))
+		if (RSA_set0_key(k->rsa, NULL, NULL, BN_new()) == 0 ||
+		    RSA_set0_factors(k->rsa, BN_new(), BN_new()) == 0 ||
+		    RSA_set0_crt_params(k->rsa, BN_new(), BN_new(), BN_new()) == 0)
 			return SSH_ERR_ALLOC_FAIL;
 		break;
 	case KEY_DSA:
 	case KEY_DSA_CERT:
-		if (bn_maybe_alloc_failed(k->dsa->priv_key))
+		if (DSA_set0_key(k->dsa, NULL, BN_new()) == 0)
 			return SSH_ERR_ALLOC_FAIL;
 		break;
-#undef bn_maybe_alloc_failed
 	case KEY_ECDSA:
 	case KEY_ECDSA_CERT:
 		/* Cannot do anything until we know the group */
@@ -667,6 +671,12 @@ cert_compare(struct sshkey_cert *a, struct sshkey_cert *b)
 int
 sshkey_equal_public(const struct sshkey *a, const struct sshkey *b)
 {
+#ifdef WITH_OPENSSL
+	const BIGNUM *an, *ae;
+	const BIGNUM *bn, *be;
+	const BIGNUM *ap, *aq, *ag, *a_pub_key;
+	const BIGNUM  *bp, *bq, *bg, *b_pub_key;
+#endif
 #if defined(WITH_OPENSSL) && defined(OPENSSL_HAS_ECC)
 	BN_CTX *bnctx;
 #endif /* WITH_OPENSSL && OPENSSL_HAS_ECC */
@@ -680,16 +690,22 @@ sshkey_equal_public(const struct sshkey *a, const struct sshkey *b)
 	case KEY_RSA1:
 	case KEY_RSA_CERT:
 	case KEY_RSA:
+		RSA_get0_key(a->rsa, &an, &ae, NULL);
+		RSA_get0_key(b->rsa, &bn, &be, NULL);
 		return a->rsa != NULL && b->rsa != NULL &&
-		    BN_cmp(a->rsa->e, b->rsa->e) == 0 &&
-		    BN_cmp(a->rsa->n, b->rsa->n) == 0;
+		    BN_cmp(ae, be) == 0 &&
+		    BN_cmp(an, bn) == 0;
 	case KEY_DSA_CERT:
 	case KEY_DSA:
+		DSA_get0_pqg(a->dsa, &ap, &aq, &ag);
+		DSA_get0_pqg(b->dsa, &bp, &bq, &bg);
+		DSA_get0_key(a->dsa, &a_pub_key, NULL);
+		DSA_get0_key(b->dsa, &b_pub_key, NULL);
 		return a->dsa != NULL && b->dsa != NULL &&
-		    BN_cmp(a->dsa->p, b->dsa->p) == 0 &&
-		    BN_cmp(a->dsa->q, b->dsa->q) == 0 &&
-		    BN_cmp(a->dsa->g, b->dsa->g) == 0 &&
-		    BN_cmp(a->dsa->pub_key, b->dsa->pub_key) == 0;
+		    BN_cmp(ap, bp) == 0 &&
+		    BN_cmp(aq, bq) == 0 &&
+		    BN_cmp(ag, bg) == 0 &&
+		    BN_cmp(a_pub_key, b_pub_key) == 0;
 # ifdef OPENSSL_HAS_ECC
 	case KEY_ECDSA_CERT:
 	case KEY_ECDSA:
@@ -738,6 +754,10 @@ to_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain)
 {
 	int type, ret = SSH_ERR_INTERNAL_ERROR;
 	const char *typename;
+#ifdef WITH_OPENSSL
+	const BIGNUM *p, *q, *g, *pub_key;
+	const BIGNUM *n, *e;
+#endif
 
 	if (key == NULL)
 		return SSH_ERR_INVALID_ARGUMENT;
@@ -765,13 +785,15 @@ to_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain)
 		break;
 #ifdef WITH_OPENSSL
 	case KEY_DSA:
+		DSA_get0_pqg(key->dsa, &p, &q, &g);
+		DSA_get0_key(key->dsa, &pub_key, NULL);
 		if (key->dsa == NULL)
 			return SSH_ERR_INVALID_ARGUMENT;
 		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
-		    (ret = sshbuf_put_bignum2(b, key->dsa->p)) != 0 ||
-		    (ret = sshbuf_put_bignum2(b, key->dsa->q)) != 0 ||
-		    (ret = sshbuf_put_bignum2(b, key->dsa->g)) != 0 ||
-		    (ret = sshbuf_put_bignum2(b, key->dsa->pub_key)) != 0)
+		    (ret = sshbuf_put_bignum2(b, p)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, q)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, g)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, pub_key)) != 0)
 			return ret;
 		break;
 # ifdef OPENSSL_HAS_ECC
@@ -788,9 +810,10 @@ to_blob_buf(const struct sshkey *key, struct sshbuf *b, int force_plain)
 	case KEY_RSA:
 		if (key->rsa == NULL)
 			return SSH_ERR_INVALID_ARGUMENT;
+		RSA_get0_key(key->rsa, &n, &e, NULL);
 		if ((ret = sshbuf_put_cstring(b, typename)) != 0 ||
-		    (ret = sshbuf_put_bignum2(b, key->rsa->e)) != 0 ||
-		    (ret = sshbuf_put_bignum2(b, key->rsa->n)) != 0)
+		    (ret = sshbuf_put_bignum2(b, e)) != 0 ||
+		    (ret = sshbuf_put_bignum2(b, n)) != 0)
 			return ret;
 		break;
 #endif /* WITH_OPENSSL */
@@ -885,6 +908,9 @@ sshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,
 	u_char *blob = NULL, *ret = NULL;
 	size_t blob_len = 0;
 	int r = SSH_ERR_INTERNAL_ERROR;
+#ifdef WITH_OPENSSL
+	const BIGNUM *n, *e;
+#endif
 
 	if (retp != NULL)
 		*retp = NULL;
@@ -897,8 +923,9 @@ sshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,
 
 	if (k->type == KEY_RSA1) {
 #ifdef WITH_OPENSSL
-		int nlen = BN_num_bytes(k->rsa->n);
-		int elen = BN_num_bytes(k->rsa->e);
+		RSA_get0_key(k->rsa, &n, &e, NULL);
+		int nlen = BN_num_bytes(n);
+		int elen = BN_num_bytes(e);
 
 		blob_len = nlen + elen;
 		if (nlen >= INT_MAX - elen ||
@@ -906,8 +933,8 @@ sshkey_fingerprint_raw(const struct sshkey *k, int dgst_alg,
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		BN_bn2bin(k->rsa->n, blob);
-		BN_bn2bin(k->rsa->e, blob + nlen);
+		BN_bn2bin(n, blob);
+		BN_bn2bin(e, blob + nlen);
 #endif /* WITH_OPENSSL */
 	} else if ((r = to_blob(k, &blob, &blob_len, 1)) != 0)
 		goto out;
@@ -1775,7 +1802,10 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 {
 	struct sshkey *n = NULL;
 	int ret = SSH_ERR_INTERNAL_ERROR;
-
+#ifdef WITH_OPENSSL
+	BIGNUM *p, *q, *g, *pub_key;
+	BIGNUM *rsa_n, *rsa_e;
+#endif
 	if (pkp != NULL)
 		*pkp = NULL;
 
@@ -1785,10 +1815,10 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 	case KEY_DSA_CERT:
 		if ((n = sshkey_new(k->type)) == NULL)
 			return SSH_ERR_ALLOC_FAIL;
-		if ((BN_copy(n->dsa->p, k->dsa->p) == NULL) ||
-		    (BN_copy(n->dsa->q, k->dsa->q) == NULL) ||
-		    (BN_copy(n->dsa->g, k->dsa->g) == NULL) ||
-		    (BN_copy(n->dsa->pub_key, k->dsa->pub_key) == NULL)) {
+		DSA_get0_pqg(k->dsa, (const BIGNUM**)&p, (const BIGNUM**)&q, (const BIGNUM**)&g);
+		DSA_get0_key(k->dsa, (const BIGNUM**)&pub_key, NULL);
+		if (DSA_set0_pqg(n->dsa, p, q, g) == 0 ||
+		    DSA_set0_key(n->dsa, pub_key, NULL) == 0) {
 			sshkey_free(n);
 			return SSH_ERR_ALLOC_FAIL;
 		}
@@ -1816,8 +1846,8 @@ sshkey_from_private(const struct sshkey *k, struct sshkey **pkp)
 	case KEY_RSA_CERT:
 		if ((n = sshkey_new(k->type)) == NULL)
 			return SSH_ERR_ALLOC_FAIL;
-		if ((BN_copy(n->rsa->n, k->rsa->n) == NULL) ||
-		    (BN_copy(n->rsa->e, k->rsa->e) == NULL)) {
+		RSA_get0_key(k->rsa, (const BIGNUM**)&rsa_n, (const BIGNUM**)&rsa_e, NULL);
+		if (RSA_set0_key(n->rsa, rsa_n, rsa_e, NULL) == 0) {
 			sshkey_free(n);
 			return SSH_ERR_ALLOC_FAIL;
 		}
@@ -1980,9 +2010,13 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 	size_t len;
 	u_char *pk = NULL;
 	struct sshbuf *copy;
-#if defined(WITH_OPENSSL) && defined(OPENSSL_HAS_ECC)
+#if defined(WITH_OPENSSL)
+	BIGNUM *n, *e;
+	BIGNUM *dsa_p, *dsa_q, *dsa_g, *pub_key;
+#if defined(OPENSSL_HAS_ECC)
 	EC_POINT *q = NULL;
-#endif /* WITH_OPENSSL && OPENSSL_HAS_ECC */
+#endif /* OPENSSL_HAS_ECC */
+#endif /* WITH_OPENSSL */
 
 #ifdef DEBUG_PK /* XXX */
 	sshbuf_dump(b, stderr);
@@ -2016,8 +2050,11 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		if (sshbuf_get_bignum2(b, key->rsa->e) != 0 ||
-		    sshbuf_get_bignum2(b, key->rsa->n) != 0) {
+		if ((e = BN_new()) == NULL ||
+		    (n = BN_new()) == NULL ||
+		    sshbuf_get_bignum2(b, e) != 0 ||
+		    sshbuf_get_bignum2(b, n) != 0 ||
+		    RSA_set0_key(key->rsa, n, e, NULL) == 0) {
 			ret = SSH_ERR_INVALID_FORMAT;
 			goto out;
 		}
@@ -2037,10 +2074,14 @@ sshkey_from_blob_internal(struct sshbuf *b, struct sshkey **keyp,
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		if (sshbuf_get_bignum2(b, key->dsa->p) != 0 ||
-		    sshbuf_get_bignum2(b, key->dsa->q) != 0 ||
-		    sshbuf_get_bignum2(b, key->dsa->g) != 0 ||
-		    sshbuf_get_bignum2(b, key->dsa->pub_key) != 0) {
+		DSA_get0_pqg(key->dsa, (const BIGNUM**)&dsa_p, (const BIGNUM**)&dsa_q, (const BIGNUM**)&dsa_g);
+		DSA_get0_key(key->dsa, (const BIGNUM**)&pub_key, NULL);
+		if (sshbuf_get_bignum2(b, dsa_p) != 0 ||
+		    sshbuf_get_bignum2(b, dsa_q) != 0 ||
+		    sshbuf_get_bignum2(b, dsa_g) != 0 ||
+		    sshbuf_get_bignum2(b, pub_key) != 0 ||
+		    DSA_set0_pqg(key->dsa, dsa_p, dsa_p, dsa_g) == 0 ||
+		    DSA_set0_key(key->dsa, pub_key, NULL) == 0) {
 			ret = SSH_ERR_INVALID_FORMAT;
 			goto out;
 		}
@@ -2260,6 +2301,10 @@ sshkey_demote(const struct sshkey *k, struct sshkey **dkp)
 {
 	struct sshkey *pk;
 	int ret = SSH_ERR_INTERNAL_ERROR;
+#ifdef WITH_OPENSSL
+	const BIGNUM *n, *e;
+	const BIGNUM *p, *q, *g, *pub_key;
+#endif
 
 	if (dkp != NULL)
 		*dkp = NULL;
@@ -2283,23 +2328,23 @@ sshkey_demote(const struct sshkey *k, struct sshkey **dkp)
 		/* FALLTHROUGH */
 	case KEY_RSA1:
 	case KEY_RSA:
+		RSA_get0_key(k->rsa, &n, &e, NULL);
 		if ((pk->rsa = RSA_new()) == NULL ||
-		    (pk->rsa->e = BN_dup(k->rsa->e)) == NULL ||
-		    (pk->rsa->n = BN_dup(k->rsa->n)) == NULL) {
+		    RSA_set0_key(pk->rsa, BN_dup(n), BN_dup(e), NULL) == 0) {
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto fail;
-			}
+		}
 		break;
 	case KEY_DSA_CERT:
 		if ((ret = sshkey_cert_copy(k, pk)) != 0)
 			goto fail;
 		/* FALLTHROUGH */
 	case KEY_DSA:
+		DSA_get0_pqg(k->dsa, &p, &q, &g);
+		DSA_get0_key(k->dsa, &pub_key, NULL);
 		if ((pk->dsa = DSA_new()) == NULL ||
-		    (pk->dsa->p = BN_dup(k->dsa->p)) == NULL ||
-		    (pk->dsa->q = BN_dup(k->dsa->q)) == NULL ||
-		    (pk->dsa->g = BN_dup(k->dsa->g)) == NULL ||
-		    (pk->dsa->pub_key = BN_dup(k->dsa->pub_key)) == NULL) {
+		    DSA_set0_pqg(pk->dsa, BN_dup(p), BN_dup(q), BN_dup(g)) == 0 ||
+		    DSA_set0_key(pk->dsa, BN_dup(pub_key), NULL) == 0) {
 			ret = SSH_ERR_ALLOC_FAIL;
 			goto fail;
 		}
@@ -2397,6 +2442,9 @@ sshkey_certify(struct sshkey *k, struct sshkey *ca)
 	size_t i, ca_len, sig_len;
 	int ret = SSH_ERR_INTERNAL_ERROR;
 	struct sshbuf *cert;
+#ifdef WITH_OPENSSL
+	const BIGNUM *p, *q, *g, *n, *e, *pub_key;
+#endif
 
 	if (k == NULL || k->cert == NULL ||
 	    k->cert->certblob == NULL || ca == NULL)
@@ -2423,10 +2471,12 @@ sshkey_certify(struct sshkey *k, struct sshkey *ca)
 	switch (k->type) {
 #ifdef WITH_OPENSSL
 	case KEY_DSA_CERT:
-		if ((ret = sshbuf_put_bignum2(cert, k->dsa->p)) != 0 ||
-		    (ret = sshbuf_put_bignum2(cert, k->dsa->q)) != 0 ||
-		    (ret = sshbuf_put_bignum2(cert, k->dsa->g)) != 0 ||
-		    (ret = sshbuf_put_bignum2(cert, k->dsa->pub_key)) != 0)
+		DSA_get0_pqg(k->dsa, &p, &q, &g);
+		DSA_get0_key(k->dsa, &pub_key, NULL);
+		if ((ret = sshbuf_put_bignum2(cert, p)) != 0 ||
+		    (ret = sshbuf_put_bignum2(cert, q)) != 0 ||
+		    (ret = sshbuf_put_bignum2(cert, g)) != 0 ||
+		    (ret = sshbuf_put_bignum2(cert, pub_key)) != 0)
 			goto out;
 		break;
 # ifdef OPENSSL_HAS_ECC
@@ -2440,8 +2490,9 @@ sshkey_certify(struct sshkey *k, struct sshkey *ca)
 		break;
 # endif /* OPENSSL_HAS_ECC */
 	case KEY_RSA_CERT:
-		if ((ret = sshbuf_put_bignum2(cert, k->rsa->e)) != 0 ||
-		    (ret = sshbuf_put_bignum2(cert, k->rsa->n)) != 0)
+		RSA_get0_key(k->rsa, &n, &e, NULL);
+		if ((ret = sshbuf_put_bignum2(cert, e)) != 0 ||
+		    (ret = sshbuf_put_bignum2(cert, n)) != 0)
 			goto out;
 		break;
 #endif /* WITH_OPENSSL */
@@ -2560,18 +2611,25 @@ int
 sshkey_private_serialize(const struct sshkey *key, struct sshbuf *b)
 {
 	int r = SSH_ERR_INTERNAL_ERROR;
+#ifdef WITH_OPENSSL
+	const BIGNUM *n, *e, *d, *p, *q, *g, *iqmp;
+	const BIGNUM *pub_key, *priv_key;
+#endif
 
 	if ((r = sshbuf_put_cstring(b, sshkey_ssh_name(key))) != 0)
 		goto out;
 	switch (key->type) {
 #ifdef WITH_OPENSSL
 	case KEY_RSA:
-		if ((r = sshbuf_put_bignum2(b, key->rsa->n)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->e)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->d)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->iqmp)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->p)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->q)) != 0)
+		RSA_get0_key(key->rsa, &n, &e, &d);
+		RSA_get0_factors(key->rsa, &p, &q);
+		RSA_get0_crt_params(key->rsa, NULL, NULL, &iqmp);
+		if ((r = sshbuf_put_bignum2(b, n)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, e)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, d)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, iqmp)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, p)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, q)) != 0)
 			goto out;
 		break;
 	case KEY_RSA_CERT:
@@ -2579,28 +2637,34 @@ sshkey_private_serialize(const struct sshkey *key, struct sshbuf *b)
 			r = SSH_ERR_INVALID_ARGUMENT;
 			goto out;
 		}
+		RSA_get0_key(key->rsa, &n, &e, &d);
+		RSA_get0_factors(key->rsa, &p, &q);
+		RSA_get0_crt_params(key->rsa, NULL, NULL, &iqmp);
 		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->d)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->iqmp)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->p)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->rsa->q)) != 0)
+		    (r = sshbuf_put_bignum2(b, d)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, iqmp)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, p)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, q)) != 0)
 			goto out;
 		break;
 	case KEY_DSA:
-		if ((r = sshbuf_put_bignum2(b, key->dsa->p)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->dsa->q)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->dsa->g)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->dsa->pub_key)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->dsa->priv_key)) != 0)
+		DSA_get0_pqg(key->dsa, &p, &q, &g);
+		DSA_get0_key(key->dsa, &pub_key, &priv_key);
+		if ((r = sshbuf_put_bignum2(b, p)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, q)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, g)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, pub_key)) != 0 ||
+		    (r = sshbuf_put_bignum2(b, priv_key)) != 0)
 			goto out;
 		break;
 	case KEY_DSA_CERT:
+		DSA_get0_key(key->dsa, NULL, &priv_key);
 		if (key->cert == NULL || sshbuf_len(key->cert->certblob) == 0) {
 			r = SSH_ERR_INVALID_ARGUMENT;
 			goto out;
 		}
 		if ((r = sshbuf_put_stringb(b, key->cert->certblob)) != 0 ||
-		    (r = sshbuf_put_bignum2(b, key->dsa->priv_key)) != 0)
+		    (r = sshbuf_put_bignum2(b, priv_key)) != 0)
 			goto out;
 		break;
 # ifdef OPENSSL_HAS_ECC
@@ -2663,6 +2727,8 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 	u_char *ed25519_pk = NULL, *ed25519_sk = NULL;
 #ifdef WITH_OPENSSL
 	BIGNUM *exponent = NULL;
+	BIGNUM *p, *q, *g, *pub_key, *priv_key;
+	BIGNUM *n, *e, *d, *iqmp;
 #endif /* WITH_OPENSSL */
 
 	if (kp != NULL)
@@ -2677,17 +2743,26 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		if ((r = sshbuf_get_bignum2(buf, k->dsa->p)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->dsa->q)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->dsa->g)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->dsa->pub_key)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->dsa->priv_key)) != 0)
+		if ((p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (g = BN_new()) == NULL ||
+		    (pub_key = BN_new()) == NULL ||
+		    (priv_key = BN_new()) == NULL ||
+		    (r = sshbuf_get_bignum2(buf, p)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, q)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, g)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, pub_key)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, priv_key)) != 0 ||
+		    DSA_set0_pqg(k->dsa, p, q, g) == 0 ||
+		    DSA_set0_key(k->dsa, pub_key, priv_key) == 0)
 			goto out;
 		break;
 	case KEY_DSA_CERT:
-		if ((r = sshkey_froms(buf, &k)) != 0 ||
+		if ((priv_key = BN_new()) == NULL ||
+		    (r = sshkey_froms(buf, &k)) != 0 ||
 		    (r = sshkey_add_private(k)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->dsa->priv_key)) != 0)
+		    (r = sshbuf_get_bignum2(buf, priv_key)) != 0 ||
+		    DSA_set0_key(k->dsa, NULL, priv_key) == 0)
 			goto out;
 		break;
 # ifdef OPENSSL_HAS_ECC
@@ -2747,23 +2822,39 @@ sshkey_private_deserialize(struct sshbuf *buf, struct sshkey **kp)
 			r = SSH_ERR_ALLOC_FAIL;
 			goto out;
 		}
-		if ((r = sshbuf_get_bignum2(buf, k->rsa->n)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->e)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->d)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->iqmp)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->p)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->q)) != 0 ||
-		    (r = rsa_generate_additional_parameters(k->rsa)) != 0)
+		if ((n = BN_new()) == NULL ||
+		    (e = BN_new()) == NULL ||
+		    (d = BN_new()) == NULL ||
+		    (iqmp = BN_new()) == NULL ||
+		    (p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (r = sshbuf_get_bignum2(buf, n)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, e)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, d)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, iqmp)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, p)) != 0 ||
+		    (r = sshbuf_get_bignum2(buf, q)) != 0 ||
+		    (r = rsa_generate_additional_parameters(k->rsa)) != 0 ||
+		    RSA_set0_key(k->rsa, n, e, d) == 0 ||
+		    RSA_set0_factors(k->rsa, p, q) == 0 ||
+		    RSA_set0_crt_params(k->rsa, NULL, NULL, iqmp) == 0)
 			goto out;
 		break;
 	case KEY_RSA_CERT:
-		if ((r = sshkey_froms(buf, &k)) != 0 ||
+		if ((d = BN_new()) == NULL ||
+		    (iqmp = BN_new()) == NULL ||
+		    (p = BN_new()) == NULL ||
+		    (q = BN_new()) == NULL ||
+		    (r = sshkey_froms(buf, &k)) != 0 ||
 		    (r = sshkey_add_private(k)) != 0 ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->d) != 0) ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->iqmp) != 0) ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->p) != 0) ||
-		    (r = sshbuf_get_bignum2(buf, k->rsa->q) != 0) ||
-		    (r = rsa_generate_additional_parameters(k->rsa)) != 0)
+		    (r = sshbuf_get_bignum2(buf, d) != 0) ||
+		    (r = sshbuf_get_bignum2(buf, iqmp) != 0) ||
+		    (r = sshbuf_get_bignum2(buf, p) != 0) ||
+		    (r = sshbuf_get_bignum2(buf, q) != 0) ||
+		    (r = rsa_generate_additional_parameters(k->rsa)) != 0 ||
+		    RSA_set0_key(k->rsa, NULL, NULL, d) == 0 ||
+		    RSA_set0_factors(k->rsa, p, q) == 0 ||
+		    RSA_set0_crt_params(k->rsa, NULL, NULL, iqmp) == 0)
 			goto out;
 		break;
 #endif /* WITH_OPENSSL */
@@ -3781,7 +3872,7 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 		r = SSH_ERR_KEY_WRONG_PASSPHRASE;
 		goto out;
 	}
-	if (pk->type == EVP_PKEY_RSA &&
+	if (EVP_PKEY_id(pk) == EVP_PKEY_RSA &&
 	    (type == KEY_UNSPEC || type == KEY_RSA)) {
 		if ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
@@ -3796,7 +3887,7 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 			r = SSH_ERR_LIBCRYPTO_ERROR;
 			goto out;
 		}
-	} else if (pk->type == EVP_PKEY_DSA &&
+	} else if (EVP_PKEY_id(pk) == EVP_PKEY_DSA &&
 	    (type == KEY_UNSPEC || type == KEY_DSA)) {
 		if ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
@@ -3808,7 +3899,7 @@ sshkey_parse_private_pem_fileblob(struct sshbuf *blob, int type,
 		DSA_print_fp(stderr, prv->dsa, 8);
 #endif
 #ifdef OPENSSL_HAS_ECC
-	} else if (pk->type == EVP_PKEY_EC &&
+	} else if (EVP_PKEY_id(pk) == EVP_PKEY_EC &&
 	    (type == KEY_UNSPEC || type == KEY_ECDSA)) {
 		if ((prv = sshkey_new(KEY_UNSPEC)) == NULL) {
 			r = SSH_ERR_ALLOC_FAIL;
