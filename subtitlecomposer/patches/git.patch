diff -Naupr a/po/ar/subtitlecomposer.po n/po/ar/subtitlecomposer.po
diff -Naupr a/po/bg/subtitlecomposer.po n/po/bg/subtitlecomposer.po
diff -Naupr a/po/ca/subtitlecomposer.po n/po/ca/subtitlecomposer.po
diff -Naupr a/po/ca@valencia/subtitlecomposer.po n/po/ca@valencia/subtitlecomposer.po
diff -Naupr a/po/cs/subtitlecomposer.po n/po/cs/subtitlecomposer.po
diff -Naupr a/po/de/subtitlecomposer.po n/po/de/subtitlecomposer.po
diff -Naupr a/po/el/subtitlecomposer.po n/po/el/subtitlecomposer.po
diff -Naupr a/po/en_GB/subtitlecomposer.po n/po/en_GB/subtitlecomposer.po
diff -Naupr a/po/eo/subtitlecomposer.po n/po/eo/subtitlecomposer.po
diff -Naupr a/po/es/subtitlecomposer.po n/po/es/subtitlecomposer.po
diff -Naupr a/po/et/subtitlecomposer.po n/po/et/subtitlecomposer.po
diff -Naupr a/po/fi/subtitlecomposer.po n/po/fi/subtitlecomposer.po
diff -Naupr a/po/fr/subtitlecomposer.po n/po/fr/subtitlecomposer.po
diff -Naupr a/po/gl/subtitlecomposer.po n/po/gl/subtitlecomposer.po
diff -Naupr a/po/hr/subtitlecomposer.po n/po/hr/subtitlecomposer.po
diff -Naupr a/po/hu/subtitlecomposer.po n/po/hu/subtitlecomposer.po
diff -Naupr a/po/ie/subtitlecomposer.po n/po/ie/subtitlecomposer.po
diff -Naupr a/po/it/subtitlecomposer.po n/po/it/subtitlecomposer.po
diff -Naupr a/po/ja/subtitlecomposer.po n/po/ja/subtitlecomposer.po
diff -Naupr a/po/ka/subtitlecomposer.po n/po/ka/subtitlecomposer.po
diff -Naupr a/po/lt/subtitlecomposer.po n/po/lt/subtitlecomposer.po
diff -Naupr a/po/nl/subtitlecomposer.po n/po/nl/subtitlecomposer.po
diff -Naupr a/po/pl/subtitlecomposer.po n/po/pl/subtitlecomposer.po
diff -Naupr a/po/pt/subtitlecomposer.po n/po/pt/subtitlecomposer.po
diff -Naupr a/po/pt_BR/subtitlecomposer.po n/po/pt_BR/subtitlecomposer.po
diff -Naupr a/po/ru/subtitlecomposer.po n/po/ru/subtitlecomposer.po
diff -Naupr a/po/sk/subtitlecomposer.po n/po/sk/subtitlecomposer.po
diff -Naupr a/po/sl/subtitlecomposer.po n/po/sl/subtitlecomposer.po
diff -Naupr a/po/sv/subtitlecomposer.po n/po/sv/subtitlecomposer.po
diff -Naupr a/po/tr/subtitlecomposer.po n/po/tr/subtitlecomposer.po
diff -Naupr a/po/uk/subtitlecomposer.po n/po/uk/subtitlecomposer.po
diff -Naupr a/po/zh_CN/subtitlecomposer.po n/po/zh_CN/subtitlecomposer.po
diff -Naupr a/po/zh_TW/subtitlecomposer.po n/po/zh_TW/subtitlecomposer.po
diff -Naupr a/src/CMakeLists.txt n/src/CMakeLists.txt
--- a/src/CMakeLists.txt	2024-06-08 04:22:21.000000000 +0200
+++ n/src/CMakeLists.txt	2024-08-11 03:49:35.000000000 +0200
@@ -5,6 +5,14 @@ endif()
 
 if(CMAKE_COMPILER_IS_GNUCC)
 	message(STATUS "GNU C compiler detected")
+	if(SC_NO_DEPRECATED)
+		set(CMAKE_C_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Wno-deprecated-declarations")
+		set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Wno-deprecated-declarations")
+	endif()
+	if(SC_WARN_ERRORS)
+		set(CMAKE_C_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Werror")
+		set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Werror")
+	endif()
 	set(CMAKE_C_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Wall -Og -g")
 	set(CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -Wall -Og -g")
 	set(CMAKE_C_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -Wall -O3")
@@ -25,7 +33,7 @@ if(APPIMAGE)
 	set(SC_APPIMAGE 1 CACHE INTERNAL EXPORTEDVARIABLE)
 endif()
 
-find_package(FFmpeg 57.83.100 REQUIRED)
+find_package(FFmpeg 59.27.100 REQUIRED)
 find_package(OpenAL REQUIRED)
 find_package(ICU)
 
diff -Naupr a/src/core/subtitle.cpp n/src/core/subtitle.cpp
--- a/src/core/subtitle.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/core/subtitle.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -45,15 +45,13 @@ Subtitle::Subtitle(double framesPerSecon
 	  m_secondaryDirtyState(false),
 	  m_secondaryCleanIndex(0),
 	  m_framesPerSecond(framesPerSecond),
-	  m_stylesheet(new RichCSS()),
+	  m_stylesheet(new RichCSS(this)),
 	  m_formatData(nullptr)
 {}
 
 Subtitle::~Subtitle()
 {
 	qDeleteAll(m_lines);
-
-	delete m_stylesheet;
 	delete m_formatData;
 }
 
diff -Naupr a/src/gui/waveform/waverenderer.cpp n/src/gui/waveform/waverenderer.cpp
--- a/src/gui/waveform/waverenderer.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/gui/waveform/waverenderer.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -27,7 +27,6 @@ WaveRenderer::WaveRenderer(WaveformWidge
 	: QWidget(parent),
 	  m_wfw(parent)
 {
-	setAttribute(Qt::WA_OpaquePaintEvent, true);
 	setAttribute(Qt::WA_NoSystemBackground, true);
 	setSizePolicy(QSizePolicy::Expanding, QSizePolicy::Expanding);
 	setMouseTracking(true);
diff -Naupr a/src/org.kde.subtitlecomposer.appdata.xml n/src/org.kde.subtitlecomposer.appdata.xml
--- a/src/org.kde.subtitlecomposer.appdata.xml	2024-06-08 04:22:21.000000000 +0200
+++ n/src/org.kde.subtitlecomposer.appdata.xml	2024-08-11 03:49:35.000000000 +0200
@@ -3,6 +3,9 @@
   <id>org.kde.subtitlecomposer</id>
   <metadata_license>CC0-1.0</metadata_license>
   <project_license>GPL-2.0+</project_license>
+  <developer id="org.kde">
+    <name translate="no">KDE</name>
+  </developer>
   <name>Subtitle Composer</name>
   <name xml:lang="ca">Subtitle Composer</name>
   <name xml:lang="ca-valencia">Subtitle Composer</name>
@@ -14,6 +17,7 @@
   <name xml:lang="et">Subtiitriredaktor</name>
   <name xml:lang="fi">Subtitle Composer</name>
   <name xml:lang="fr">Subtitle Composer</name>
+  <name xml:lang="gl">Subtitle Composer</name>
   <name xml:lang="id">Subtitle Composer</name>
   <name xml:lang="it">Subtitle Composer</name>
   <name xml:lang="ka">სუბტიტრების შედგენა</name>
@@ -40,6 +44,7 @@
   <summary xml:lang="et">Videosubtiitrite redaktor, mis toetab nii põhilisi ja kui ka spetsiifilisemaid muutmistoiminguid</summary>
   <summary xml:lang="fi">Videotekstitysmuokkain, joka tukee tavallisia ja edistyneitä muokkaustoimenpiteitä</summary>
   <summary xml:lang="fr">Éditeur de sous-titres vidéo prenant en charge des opérations d'édition basiques et avancées</summary>
+  <summary xml:lang="gl">Editor de subtítulos de vídeo que permite operacións de edición básicas e avanzadas.</summary>
   <summary xml:lang="id">Editor subtitle video yang mendukung operasi pengeditan dasar dan tingkat lanjut</summary>
   <summary xml:lang="it">Editor di sottotitoli video che supporta operazioni di modifica di base ed avanzate</summary>
   <summary xml:lang="ka">ვიდეოს სუბტიტრების რედაქტორი, რომელსაც ჩასწორების ოპერაციების ორივე, მარტივი და რთული შემთხვევების ჩატარება შეუძლია</summary>
@@ -66,6 +71,7 @@
     <p xml:lang="et">Subtiitriredaktor on avatud lähtekoodiga tekstipõhine subtiitrite redaktor, mis toetab nii põhilisi kui ka spetsiifilisemaid muutmistoiminguid.</p>
     <p xml:lang="fi">Subtitle Composer on avoimen lähdekoodin tekstipohjainen tekstitysmuokkain, joka tukee tavallisia ja edistyneitä muokkaustoimenpiteitä</p>
     <p xml:lang="fr">Subtitle Composer est un éditeur de sous-titres textes libre prenant en charge des opérations d'édition basiques et avancées.</p>
+    <p xml:lang="gl">Subtitle Composer é un editor de subtítulos de vídeo libre baseado en texto que permite operacións de edición básicas e avanzadas.</p>
     <p xml:lang="id">Subtitle Composer adalah editor subtitle berbasis teks open source yang mendukung operasi pengeditan dasar dan tingkat lanjut.</p>
     <p xml:lang="it">Subtitle Composer è un editor di sottotitoli open source basato sul testo che supporta operazioni di modifica di base ed avanzate.</p>
     <p xml:lang="ka">Subtitle Composer-ი ღია კოდის მქონე სუბტიტრების რედაქტორია, რომელსაც ორივე, ძირითადი და დამატებითი ოპერაციების ჩატარების საშუალება გააჩნია.</p>
@@ -92,6 +98,7 @@
     <p xml:lang="et">Omadused</p>
     <p xml:lang="fi">Ominaisuuksia</p>
     <p xml:lang="fr">Fonctionnalités</p>
+    <p xml:lang="gl">Funcionalidades:</p>
     <p xml:lang="id">Fitur</p>
     <p xml:lang="it">Caratteristiche</p>
     <p xml:lang="ka">თვისებები</p>
@@ -119,6 +126,7 @@
       <li xml:lang="et">Subtiitrite tekstivormingute - SubRip/SRT, MicroDVD, SSA/ASS, MPlayer, TMPlayer ja YouTube - avamine ja salvestamine</li>
       <li xml:lang="fi">Avaa ja tallenna eri tekstitystiedostomuotoja: SubRip/SRT, MicroDVD, SSA/ASS, MPlayer, TMPlayer ja YouTube</li>
       <li xml:lang="fr">Ouverture et enregistrement de formats de sous-titres texte - SubRip / SRT, Micro-DVD, SSA / ASS, MPlayer, TMPlayer et YouTube</li>
+      <li xml:lang="gl">Abrir e gardar formatos de subtítulos de texto: SubRip/SRT, MicroDVD, SSA/ASS, MPlayer, TMPlayer e lendas de YouTube.</li>
       <li xml:lang="id">Buka/Simpan Format Subtitle Teks - SubRip/SRT, MicroDVD, SSA/ASS, MPlayer, TMPlayer dan bab YouTube</li>
       <li xml:lang="it">Apertura/salvataggio di formati di sottotitoli di testo - SubRip/SRT, MicroDVD, SSA/ASS, MPlayer, TMPlayer e sottotitoli YouTube</li>
       <li xml:lang="ko">텍스트 자막 형식 열고 저장 - SubRip/SRT, MicroDVD, SSA/ASS, MPlayer, TMPlayer, YouTube 캡션</li>
@@ -142,6 +150,7 @@
       <li xml:lang="et">Subtiitrite graafikavormingute - VobSub (.idx/.sub/.rar), BluRay/PGS (*.sup), ffmpeg toetatud vormingud (DVD/Vob, DVB, XSUB, HDMV-PGS) - avamine ja optiline märgituvastus</li>
       <li xml:lang="fi">Avaa ja lue graafisia tekstitystiedostomuotoja: VobSub (.idx/.sub/.rar), BluRay/PGS (*.sup) sekä ffmpegin tukemat muodot (DVD/Vob, DVB, XSUB, HDMV-PGS)</li>
       <li xml:lang="fr">Ouverture et reconnaissance de caractères de formats de sous-titres graphiques - VobSub (.idx/.sub/.rar), BluRay/PGS (*.sup), formats pris en charge par ffmpeg (DVD/Vob, DVB, XSUB, HDMV-PGS)</li>
+      <li xml:lang="gl">Formatos de subtítulos gráficos abertos ou de OCR: VobSub (.idx/.sub/.rar), BluRay/PGS (*.sup) e formatos permitidos por ffmpeg (DVD/Vob, DVB, XSUB, HDMV-PGS).</li>
       <li xml:lang="id">Buka/OCR Format Subtitle Grafik - VobSub (.idx/.sub/.rar), BluRay/PGS (*.sup), format-format yang didukung oleh ffmpeg (DVD/Vob, DVB, XSUB, HDMV-PGS)</li>
       <li xml:lang="it">Apertura di formati di sottotitoli grafici aperti/OCR - VobSub (.idx/.sub/.rar), BluRay/PGS (*.sup), formati supportati da ffmpeg (DVD/Vob, DVB, XSUB, HDMV-PGS)</li>
       <li xml:lang="ko">그래픽 자막을 열고 OCR 처리 - VobSub(.idx/.sub/.rar), 블루레이/PGS(*.sup), ffmpeg에서 지원하는 형식(DVD/Vob, DVB, XSUB, HDMV-PGS)</li>
@@ -165,6 +174,7 @@
       <li xml:lang="et">Graafilise või tekstisubtiitri voo demultipleksimine videofailist - SRT, SSA/ASS, MOV text, MicroDVD, DVD/Vob, DVB, XSUB, HDMV-PGS</li>
       <li xml:lang="fi">Graafisten tai tekstimuotoisten tekstitysten demuksaus videotiedostosta: SRT, SSA/ASS, MOV, MicroDVD, DVD/Vob, DVB, XSUB, HDMV-PGS</li>
       <li xml:lang="fr">Démultiplexage du flux de sous-titres graphiques / texte depuis un fichier vidéo - SRT, SSA / ASS, MOV texte, Micro-DVD, DVD / Vob, DVB, XSUB, HDMV-PGS</li>
+      <li xml:lang="gl">Gráficos de demultiplexión ou fluxo de subtítulos de texto dun ficheiro de vídeo: SRT, SSA/ASS, texto de MOV, MicroDVD, DVD/Vob, DVB, XSUB e HDMV-PGS.</li>
       <li xml:lang="id">Stream Subtitle Teks/Demux Graphics dari file video - SRT, SSA/ASS, MOV text, MicroDVD, DVD/Vob, DVB, XSUB, HDMV-PGS</li>
       <li xml:lang="it">Demultiplazione di flussi di sottotitoli grafici/di testo - SRT, SSA/ASS, testo MOV, MicroDVD, DVD/Vob, DVB, XSUB, HDMV-PGS</li>
       <li xml:lang="ko">동영상 파일에서 그래픽/텍스트 자막 스트림 디먹스 - SRT, SSA/ASS, MOV 텍스트, MicroDVD, DVD/Vob, DVB, XSUB, HDMV-PGS</li>
@@ -188,6 +198,7 @@
       <li xml:lang="et">Kõne tuvastamine heli/videofailist PocketSphinxi abil</li>
       <li xml:lang="fi">Puheentunnistus ääni- tai videotiedostosta PocketSphinxillä</li>
       <li xml:lang="fr">Reconnaissance vocale des fichiers audio / vidéo grâce à PocketSphinx</li>
+      <li xml:lang="gl">Recoñecemento de fala a partir de ficheiros de son ou de vídeo mediante PocketSphinx.</li>
       <li xml:lang="id">Pengenalan lisan dari file audio/video menggunakan PocketSphinx</li>
       <li xml:lang="it">Riconoscimento della voce da file audio/video tramite PocketSphinx</li>
       <li xml:lang="ko">PocketSphinx를 사용하여 오디오/동영상 파일의 음성 인식</li>
@@ -212,6 +223,7 @@
       <li xml:lang="et">Nutikas keele/tekstikodeeringu** tuvastamine</li>
       <li xml:lang="fi">Älykäs kielen ja merkistökoodauksen** tunnistaminen</li>
       <li xml:lang="fr">Détection intelligente de la langue et de l'encodage du texte**</li>
+      <li xml:lang="gl">Detección intelixente de idioma e codificación de texto**.</li>
       <li xml:lang="id">Deteksi encoding** teks/bahasa yang cerdas</li>
       <li xml:lang="it">Riconoscimento intelligente di linguaggio/codifica del testo**</li>
       <li xml:lang="ko">똑똑한 언어/텍스트 인코딩** 감지</li>
@@ -236,6 +248,7 @@
       <li xml:lang="et">Subtiitrite reaalajas eelvaatlus lõimitud videomängijas võimalusega valida helivoog</li>
       <li xml:lang="fi">Tekstitysten elävä esikatselu integroidussa videosoittimessa ja äänikanavan valinta</li>
       <li xml:lang="fr">Aperçu en direct des sous-titres dans le lecteur vidéo intégré avec sélection du flux audio</li>
+      <li xml:lang="gl">Previsualizar en vivo de subtítulos nun reprodutor de vídeo integrado con selección de fluxo de son.</li>
       <li xml:lang="id">Pratinjau langsung subtitle dalam pemutar video yang terintegrasi w/ seleksi stream audio</li>
       <li xml:lang="it">Anteprima dal vivo dei sottotitoli nel riproduttore multimediale integrato con selezione del flusso audio</li>
       <li xml:lang="ko">오디오 스트림 선택 기능이 있는 통합된 동영상 재생기로 자막 즉시 미리 보기</li>
@@ -260,6 +273,7 @@
       <li xml:lang="et">Subtiitrite eelvaatlus/muutmine graafilist helilainet töödeldes võimalusega valida helivoog</li>
       <li xml:lang="fi">Tekstitysten esikatselu ja muokkaus graafisena ääniaaltona sekä äänikanavan valinta</li>
       <li xml:lang="fr">Aperçu et édition des sous-titres sur un graphique de forme d'onde avec sélection du flux audio</li>
+      <li xml:lang="gl">Vista previa ou edición de subtítulos en forma de onda de son gráfica con selección de fluxo de son.</li>
       <li xml:lang="id">Pratinjau/pengeditan subtitle di bidang gelombang audio grafis w/ seleksi stream audio</li>
       <li xml:lang="it">Anteprima/modifica di sottotitoli su forme d'onda audio grafiche con selezione del flusso audio</li>
       <li xml:lang="ko">오디오 스트림 선택 기능이 있는 그래픽 오디오 파형과 함께 자막 미리 보기/편집</li>
@@ -283,6 +297,7 @@
       <li xml:lang="et">Sünkroonimine ankruid/kinnispunkte lohistades ja ajatelge venitades</li>
       <li xml:lang="fi">Synkronointi ankkureita tai tarttumapisteitä vetämällä ja aikajanaa venyttämällä</li>
       <li xml:lang="fr">Synchronisation en faisant glisser des ancres ou des points de greffe et en étirant la chronologie</li>
+      <li xml:lang="gl">Sincronizar arrastrando varias áncoras e puntos de conexión e estiramento de cronoloxía.</li>
       <li xml:lang="id">Sinkron berdasarkan menyeret beberapa jangkar/graftpoints dan timeline peregangan</li>
       <li xml:lang="it">Sincronizza trascinando varie ancore/punti di aggancio e allungando la linea temporale</li>
       <li xml:lang="ko">조절점을 드래그하여 동기화 조정 및 타임라인 펼치기</li>
@@ -307,6 +322,7 @@
       <li xml:lang="et">Aja nihutamine ja skaleerimine, ridade kestuse ümberarvutamine, kaadrisageduse teisendused jms.</li>
       <li xml:lang="fi">Ajansiirto ja -skaalaus, rivien keston laskenta, kuvanopeusmuunnokset ym.</li>
       <li xml:lang="fr">Décalage et mise à l'échelle temporelle, re-calcul de la durée des lignes, conversion du nombre d'images par seconde, etc.</li>
+      <li xml:lang="gl">Desprazamento de tempo e escala, actualización do cálculo da duración das liñas, conversión de taxa de fotogramas, etc.</li>
       <li xml:lang="id">Pergeseran waktu dan penskalaan, penghitungan ulang durasi baris, konversi framerate, dll.</li>
       <li xml:lang="it">Differita e scalatura, ricalcolo della durata delle linee, conversione della frequenza dei fotogrammi, ecc.</li>
       <li xml:lang="ko">타임시프트 및 속도 조절, 각각 대사 시간 재계산, 프레임 레이트 변환 등.</li>
@@ -331,6 +347,7 @@
       <li xml:lang="et">Subtiitrifailide ühendamine ja tükeldamine</li>
       <li xml:lang="fi">Tekstitystiedostojen yhdistäminen ja jakaminen</li>
       <li xml:lang="fr">Fusion et fractionnement de fichiers de sous-titres</li>
+      <li xml:lang="gl">Unión e división de ficheiros de subtítulo.</li>
       <li xml:lang="id">Penyatuan dan pembelahan file subtitle</li>
       <li xml:lang="it">Unione e divisione di file di sottotitoli</li>
       <li xml:lang="ka">სუბტიტრის ფაილების დაყოფა და შერწყმა</li>
@@ -356,6 +373,7 @@
       <li xml:lang="et">Subtiitrite kahes veerus tõlkimine</li>
       <li xml:lang="fi">Tekstitys ja sen käännös esittäminen rinnakkain</li>
       <li xml:lang="fr">Traductions de sous-titres côte à côte</li>
+      <li xml:lang="gl">Tradución de subtítulos lado a lado.</li>
       <li xml:lang="id">Sisi demi sisi terjemahan subtitle</li>
       <li xml:lang="it">Traduzione sottotitoli fianco a fianco</li>
       <li xml:lang="ko">양쪽으로 자막 번역</li>
@@ -380,6 +398,7 @@
       <li xml:lang="et">Tekstistiilid (kaldkiri, rasvane kiri, allajoonimine, läbikriipsutamine, värv)</li>
       <li xml:lang="fi">Tekstityylit (kursiivi, lihavointi, alle- ja yliviivaus, värit)</li>
       <li xml:lang="fr">Styles de texte (italique, gras, souligné, barré, couleur)</li>
+      <li xml:lang="gl">Estilos de texto (cursiva, grosa, subliñado, trazo, cor).</li>
       <li xml:lang="id">gaya teks (miring, tebal, garis bawah, rusuk, warna)</li>
       <li xml:lang="it">Stili di testo (corsivo, grassetto, sottolineato, barrato, colorato)</li>
       <li xml:lang="ka">ტექსტის სტილები (კურსივი, სქელი, ხაზგასმული, ხაზგადასმული, ფერადი)</li>
@@ -406,6 +425,7 @@
       <li xml:lang="et">Õigekirja kontroll</li>
       <li xml:lang="fi">Oikeinkirjoituksen tarkistus</li>
       <li xml:lang="fr">Vérification orthographique</li>
+      <li xml:lang="gl">Corrección ortográfica.</li>
       <li xml:lang="id">Pengecekan ejaan</li>
       <li xml:lang="it">Controllo ortografico</li>
       <li xml:lang="ka">მართლწერის შემოწმება</li>
@@ -432,6 +452,7 @@
       <li xml:lang="et">Ajastamisvigade tuvastamine subtiitrites</li>
       <li xml:lang="fi">Tekstityksen ajoitusvirheiden tunnistus</li>
       <li xml:lang="fr">Détection des erreurs de minutage des sous-titres</li>
+      <li xml:lang="gl">Detección de erros de tempos nos subtítulos.</li>
       <li xml:lang="id">Pendeteksian timing error pada subtitle</li>
       <li xml:lang="it">Rilevamento di errori temporali nei sottotitoli</li>
       <li xml:lang="ka">სუბტიტრებში დროის შეცდომების გადამოწმება</li>
@@ -457,6 +478,7 @@
       <li xml:lang="et">Skriptide kasutamise võimalus (JavaScript, Python, Ruby ja teised Krossi toetatud keeled).</li>
       <li xml:lang="fi">Skriptaus (JavaScript, Python, Ruby ja muut Krossin tukemat kielet)</li>
       <li xml:lang="fr">Scripts (JavaScript, Python, Ruby et autres langages pris en charge par Kross).</li>
+      <li xml:lang="gl">Guionización (JavaScript, Python, Ruby e outras linguaxes permitidas por Kross).</li>
       <li xml:lang="id">Penyekripan (JavaScript, Python, Ruby dan bahasa lainnya yang didukung oleh Kross).</li>
       <li xml:lang="it">Scripting (JavaScript, Python, Ruby ed altri linguaggi supportati da Kross).</li>
       <li xml:lang="ka">სკრიპტები (JavaScript, Python, Ruby და Kross-ის მიერ მხარდაჭერილი სხვა ენები).</li>
@@ -489,6 +511,7 @@
       <caption xml:lang="et">Rakenduse peaaken</caption>
       <caption xml:lang="fi">Sovelluksen pääikkuna</caption>
       <caption xml:lang="fr">Fenêtre principale de l'application</caption>
+      <caption xml:lang="gl">Xanela principal da aplicación.</caption>
       <caption xml:lang="id">Jendela utama aplikasi</caption>
       <caption xml:lang="it">Finestra principale dell'applicazione</caption>
       <caption xml:lang="ka">აპლიკაციის მთავარი ფანჯარა</caption>
@@ -533,6 +556,23 @@
           <li>Dropped KIO file operations</li>
         </ul>
       </description>
+      <artifacts>
+        <artifact type="binary" platform="x86_64-linux-gnu">
+          <location>https://downloadcontent.opensuse.org/repositories/home:/maxrd2/AppImage/subtitlecomposer-latest-x86_64.AppImage</location>
+          <checksum type="sha256">1222fd30bbcaf3586dfb78db27376e5e4852cb3f5d98878e2bff0744536bfcb7</checksum>
+          <size type="download">59066312</size>
+        </artifact>
+        <artifact type="binary" platform="i386-linux-gnu">
+          <location>https://downloadcontent.opensuse.org/repositories/home:/maxrd2/AppImage/subtitlecomposer-latest-i686.AppImage</location>
+          <checksum type="sha256">2fea6c3e0a9d20a2d296ff8ab078a1fafbd2dbbafb0e315d312f9ab9c2759507</checksum>
+          <size type="download">63463856</size>
+        </artifact>
+        <artifact type="source">
+          <location>https://download.kde.org/stable/subtitlecomposer/subtitlecomposer-0.8.1.tar.xz</location>
+          <checksum type="sha256">23c022768d7422c092149f41d51ebea80f54b27655573cf43f736efb88c30027</checksum>
+          <size type="download">763276</size>
+        </artifact>
+      </artifacts>
     </release>
     <release version="0.8.0" date="2023-11-06">
       <url>https://subtitlecomposer.kde.org/2023/11/06/subtitle-composer-0.8.0-released.html</url>
@@ -580,13 +620,11 @@
           <location>https://downloadcontent.opensuse.org/repositories/home:/maxrd2/AppImage/subtitlecomposer-latest-x86_64.AppImage</location>
           <checksum type="sha256">2c67d5d68e9a765a97b57f6aa623ddce7e2d1c997ee7e28bddad5636c6af98b2</checksum>
           <size type="download">59033544</size>
-          <bundle type="appimage">subtitlecomposer-latest</bundle>
         </artifact>
         <artifact type="binary" platform="i386-linux-gnu">
           <location>https://downloadcontent.opensuse.org/repositories/home:/maxrd2/AppImage/subtitlecomposer-latest-i686.AppImage</location>
           <checksum type="sha256">d654d044cb93df5eca8aa9d5cfce895d62b76f997c6a1c644714a8e6e77979ad</checksum>
           <size type="download">63361456</size>
-          <bundle type="appimage">subtitlecomposer-latest</bundle>
         </artifact>
         <artifact type="binary" platform="i386-windows-msvc">
           <location>https://gitlab.com/subtitlecomposer/subtitlecomposer/-/jobs/artifacts/obs/v0.8.0/download?job=mingw-win32-build</location>
@@ -631,13 +669,11 @@
           <location>https://downloadcontent.opensuse.org/repositories/home:/maxrd2/AppImage/subtitlecomposer-latest-x86_64.AppImage</location>
           <checksum type="sha256">ac124b356a008ff8358b0540d8aa7be068cd9df60b55a8bcdfed8a6c48d28dae</checksum>
           <size type="download">60078024</size>
-          <bundle type="appimage">subtitlecomposer-latest</bundle>
         </artifact>
         <artifact type="binary" platform="i386-linux-gnu">
           <location>https://downloadcontent.opensuse.org/repositories/home:/maxrd2/AppImage/subtitlecomposer-latest-i686.AppImage</location>
           <checksum type="sha256">2c2415cd69cd6074056446d8ac3f433faf3c6bed0e02a536d65df98e01ae4201</checksum>
           <size type="download">64520624</size>
-          <bundle type="appimage">subtitlecomposer-latest</bundle>
         </artifact>
         <artifact type="binary" platform="i386-windows-msvc">
           <location>https://gitlab.com/subtitlecomposer/subtitlecomposer/-/jobs/artifacts/obs/v0.7.1/download?job=mingw-win32-build</location>
diff -Naupr a/src/scconfig.kcfg n/src/scconfig.kcfg
--- a/src/scconfig.kcfg	2024-06-08 04:22:21.000000000 +0200
+++ n/src/scconfig.kcfg	2024-08-11 03:49:35.000000000 +0200
@@ -97,15 +97,27 @@
 			<label>Default Language</label>
 			<default>en_US</default>
 		</entry>
+		<entry name="autodetectLanguage" type="Bool">
+			<label>Auto detect language</label>
+			<default>true</default>
+		</entry>
 		<entry name="DefaultClient" type="String">
 			<label>Default client</label>
 			<default></default>
 		</entry>
-		<entry name="CheckUppercase" type="Bool">
-			<label>Check uppercase</label>
+		<entry name="backgroundCheckerEnabled" type="Bool">
+			<label>Background checker enabled</label>
 			<default>true</default>
 		</entry>
-		<entry name="SkipRunTogether" type="Bool">
+		<entry name="checkerEnabledByDefault" type="Bool">
+			<label>Checker enabled by default</label>
+			<default>true</default>
+		</entry>
+		<entry name="skipUppercase" type="Bool">
+			<label>Skip uppercase</label>
+			<default>false</default>
+		</entry>
+		<entry name="skipRunTogether" type="Bool">
 			<label>Skip Run Together</label>
 			<default>true</default>
 		</entry>
diff -Naupr a/src/streamprocessor/streamprocessor.cpp n/src/streamprocessor/streamprocessor.cpp
--- a/src/streamprocessor/streamprocessor.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/streamprocessor/streamprocessor.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -35,13 +35,15 @@ StreamProcessor::StreamProcessor(QObject
 	  m_avFormat(nullptr),
 	  m_avStream(nullptr),
 	  m_codecCtx(nullptr),
-	  m_swResample(nullptr)
+	  m_swResample(nullptr),
+	  m_audioChLayout(new AVChannelLayout{})
 {
 }
 
 StreamProcessor::~StreamProcessor()
 {
 	close();
+	delete m_audioChLayout;
 }
 
 bool
@@ -81,7 +83,7 @@ StreamProcessor::open(const QString &fil
 
 	m_opened = true;
 
-    return true;
+	return true;
 }
 
 void
@@ -92,6 +94,7 @@ StreamProcessor::close()
 		wait();
 	}
 
+	av_channel_layout_uninit(m_audioChLayout);
 	if(m_swResample)
 		swr_free(&m_swResample);
 	if(m_codecCtx)
@@ -273,28 +276,40 @@ StreamProcessor::initAudio(int streamInd
 		return false;
 	}
 
+	av_channel_layout_uninit(m_audioChLayout);
+
 	// figure channel layout or update stream format
-	if(!m_codecCtx->channel_layout)
-		m_codecCtx->channel_layout = av_get_default_channel_layout(m_codecCtx->channels);;
+	if(m_codecCtx->ch_layout.order != AV_CHANNEL_ORDER_NATIVE) {
+		const int cc = m_codecCtx->ch_layout.nb_channels;
+		av_channel_layout_uninit(&m_codecCtx->ch_layout);
+		av_channel_layout_default(&m_codecCtx->ch_layout, cc);
+	}
 
 	if(m_audioStreamFormat.channels() == 0) {
-		m_audioStreamFormat.setChannels(m_codecCtx->channels);
-		m_audioChannelLayout = m_codecCtx->channel_layout;
+		m_audioStreamFormat.setChannels(m_codecCtx->ch_layout.nb_channels);
+		av_channel_layout_copy(m_audioChLayout, &m_codecCtx->ch_layout);
 	} else {
-		m_audioChannelLayout = av_get_default_channel_layout(m_audioStreamFormat.channels());
+		av_channel_layout_default(m_audioChLayout, m_audioStreamFormat.channels());
 	}
 
 	// setup resampler if needed
-	const bool convChannels = m_codecCtx->channel_layout != m_audioChannelLayout;
+	const bool convChannels = av_channel_layout_compare(&m_codecCtx->ch_layout, m_audioChLayout) != 0;
 	const bool convSampleRate = m_codecCtx->sample_rate != m_audioStreamFormat.sampleRate();
 	const bool convSampleFormat = m_codecCtx->sample_fmt != m_audioSampleFormat;
 	if(convChannels || convSampleRate || convSampleFormat) {
-		m_swResample = swr_alloc_set_opts(nullptr,
-			m_audioChannelLayout, static_cast<AVSampleFormat>(m_audioSampleFormat), m_audioStreamFormat.sampleRate(),
-			m_codecCtx->channel_layout, m_codecCtx->sample_fmt, m_codecCtx->sample_rate,
-			0, nullptr);
+		swr_alloc_set_opts2(&m_swResample,
+							m_audioChLayout, AVSampleFormat(m_audioSampleFormat), m_audioStreamFormat.sampleRate(),
+							&m_codecCtx->ch_layout, m_codecCtx->sample_fmt, m_codecCtx->sample_rate,
+							0, nullptr);
 		// NOTE: swr_convert_frame() will call swr_init() and swr_config_frame() which is better as it seems m_codecCtx can
-		// end up with different config that what is actually in the stream
+		// end up with different config than what is actually in the stream
+		if(!m_swResample) {
+				av_log(nullptr, AV_LOG_ERROR,
+					   "Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\n",
+					   m_codecCtx->sample_rate, av_get_sample_fmt_name(m_codecCtx->sample_fmt), m_codecCtx->ch_layout.nb_channels,
+					   m_audioStreamFormat.sampleRate(), av_get_sample_fmt_name(AVSampleFormat(m_audioSampleFormat)), m_audioChLayout->nb_channels);
+				return false;
+		}
 	}
 
 	return true;
@@ -363,7 +378,8 @@ StreamProcessor::processAudio()
 	if(m_swResample) {
 		frameResampled = av_frame_alloc();
 		Q_ASSERT(frameResampled != nullptr);
-		frameResampled->channel_layout = m_audioChannelLayout;
+		av_channel_layout_uninit(&frameResampled->ch_layout);
+		av_channel_layout_copy(&frameResampled->ch_layout, m_audioChLayout);
 		frameResampled->sample_rate = m_audioStreamFormat.sampleRate();
 		frameResampled->format = m_audioSampleFormat;
 	}
@@ -431,8 +447,7 @@ StreamProcessor::processAudio()
 						timeFrameDuration = frameResampled->nb_samples * 1000 / frameResampled->sample_rate;
 					} else {
 						frameSize = frame->nb_samples * av_get_bytes_per_sample(static_cast<AVSampleFormat>(frame->format));
-						if(frame->pkt_duration)
-							timeFrameDuration = frame->pkt_duration * 1000 * m_avStream->time_base.num / m_avStream->time_base.den;
+						timeFrameDuration = int64_t(frame->nb_samples) * 1000 / frame->sample_rate;
 					}
 					timeFrameEnd = timeFrameStart + timeFrameDuration;
 
@@ -448,12 +463,12 @@ StreamProcessor::processAudio()
 
 					if(m_swResample) {
 						Q_ASSERT(frameResampled != nullptr);
-						emit audioDataAvailable(frameResampled->data[0], qint32(frameSize * frameResampled->channels),
+						emit audioDataAvailable(frameResampled->data[0], qint32(frameSize * frameResampled->ch_layout.nb_channels),
 							&m_audioStreamFormat, qint64(timeFrameStart + timeResampleDelay), qint64(timeFrameDuration));
 
 						drainSampleBuffer = swr_get_out_samples(m_swResample, 0) > 1000;
 					} else {
-						emit audioDataAvailable(frame->data[0], qint32(frameSize * frame->channels),
+						emit audioDataAvailable(frame->data[0], qint32(frameSize * frame->ch_layout.nb_channels),
 							&m_audioStreamFormat, qint64(timeFrameStart), qint64(timeFrameDuration));
 					}
 				} while(!conversionComplete && !isInterruptionRequested() && drainSampleBuffer);
diff -Naupr a/src/streamprocessor/streamprocessor.h n/src/streamprocessor/streamprocessor.h
--- a/src/streamprocessor/streamprocessor.h	2024-06-08 04:22:21.000000000 +0200
+++ n/src/streamprocessor/streamprocessor.h	2024-08-11 03:49:35.000000000 +0200
@@ -16,14 +16,11 @@
 
 QT_FORWARD_DECLARE_CLASS(QTimer)
 
-QT_FORWARD_DECLARE_STRUCT(AVFormatContext)
-typedef struct AVFormatContext AVFormatContext;
-QT_FORWARD_DECLARE_STRUCT(AVCodecContext)
-typedef struct AVCodecContext AVCodecContext;
-QT_FORWARD_DECLARE_STRUCT(AVStream)
-typedef struct AVStream AVStream;
-QT_FORWARD_DECLARE_STRUCT(SwrContext)
-typedef struct SwrContext SwrContext;
+struct AVFormatContext;
+struct AVCodecContext;
+struct AVStream;
+struct SwrContext;
+struct AVChannelLayout;
 
 namespace SubtitleComposer {
 
@@ -59,7 +56,7 @@ protected:
 	int findStream(int streamType, int streamIndex, bool imageSub);
 	void processAudio();
 	void processText();
-    virtual void run() override;
+	virtual void run() override;
 
 private:
 	bool m_opened;
@@ -86,7 +83,7 @@ private:
 	AVCodecContext *m_codecCtx;
 	SwrContext *m_swResample;
 	int m_audioSampleFormat;
-	uint64_t m_audioChannelLayout;
+	AVChannelLayout *m_audioChLayout;
 };
 
 }
diff -Naupr a/src/videoplayer/backend/audiodecoder.cpp n/src/videoplayer/backend/audiodecoder.cpp
--- a/src/videoplayer/backend/audiodecoder.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/audiodecoder.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -37,6 +37,8 @@ using namespace SubtitleComposer;
 AudioDecoder::AudioDecoder(VideoState *state, QObject *parent)
 	: Decoder(parent),
 	  m_vs(state),
+	  m_fmtSrc({}),
+	  m_fmtTgt({}),
 	  m_swrCtx(nullptr),
 	  m_audioBuf(nullptr),
 	  m_bufSize(0),
@@ -147,7 +149,7 @@ AudioDecoder::close()
 }
 
 bool
-AudioDecoder::open(int64_t wantChLayout, int wantNbChan, int wantSampleRate)
+AudioDecoder::open(AVChannelLayout *wantChLayout, int wantSampleRate)
 {
 	const static QMap<int, const char *> bufFmtMap = {
 		{ 4, "AL_FORMAT_QUAD16" },
@@ -158,12 +160,12 @@ AudioDecoder::open(int64_t wantChLayout,
 
 	int err;
 
-	if(wantSampleRate <= 0 || wantNbChan <= 0) {
+	if(wantSampleRate <= 0 || !wantChLayout || wantChLayout->nb_channels <= 0) {
 		av_log(nullptr, AV_LOG_ERROR, "openal: invalid sample rate or channel count!\n");
 		return false;
 	}
 
-	int availNbChan = wantNbChan;
+	int availNbChan = wantChLayout->nb_channels;
 	for(;;) {
 		while(availNbChan > 2 && !bufFmtMap.contains(availNbChan))
 			availNbChan--;
@@ -171,15 +173,15 @@ AudioDecoder::open(int64_t wantChLayout,
 			m_bufFmt = availNbChan == 2 ? AL_FORMAT_STEREO16 : AL_FORMAT_MONO16;
 			break;
 		}
-		m_bufFmt = alGetEnumValue(bufFmtMap[wantNbChan]);
+		m_bufFmt = alGetEnumValue(bufFmtMap[wantChLayout->nb_channels]);
 		if(m_bufFmt)
 			break;
 		availNbChan--;
 	}
 
-	if(!wantChLayout || wantNbChan != availNbChan || wantNbChan != av_get_channel_layout_nb_channels(wantChLayout)) {
-		wantChLayout = av_get_default_channel_layout(availNbChan);
-		wantChLayout &= ~AV_CH_LAYOUT_STEREO_DOWNMIX;
+	if(wantChLayout->nb_channels != availNbChan || wantChLayout->order != AV_CHANNEL_ORDER_NATIVE) {
+		av_channel_layout_uninit(wantChLayout);
+		av_channel_layout_default(wantChLayout, availNbChan);
 	}
 
 	m_alDev = alcOpenDevice(nullptr);
@@ -212,10 +214,14 @@ AudioDecoder::open(int64_t wantChLayout,
 
 	m_fmtTgt.fmt = AV_SAMPLE_FMT_S16;
 	m_fmtTgt.freq = wantSampleRate;
-	m_fmtTgt.channelLayout = wantChLayout;
-	m_fmtTgt.channels = availNbChan;
-	m_fmtTgt.frameSize = av_samples_get_buffer_size(nullptr, m_fmtTgt.channels, 1, m_fmtTgt.fmt, 1);
-	m_fmtTgt.bytesPerSec = av_samples_get_buffer_size(nullptr, m_fmtTgt.channels, m_fmtTgt.freq, m_fmtTgt.fmt, 1);
+	if((err = av_channel_layout_copy(&m_fmtTgt.chLayout, wantChLayout)) < 0) {
+		av_log(nullptr, AV_LOG_ERROR, "av_channel_layout_copy() failed (errL %d).\n", err);
+		close();
+		return false;
+	}
+
+	m_fmtTgt.frameSize = av_samples_get_buffer_size(nullptr, m_fmtTgt.chLayout.nb_channels, 1, m_fmtTgt.fmt, 1);
+	m_fmtTgt.bytesPerSec = av_samples_get_buffer_size(nullptr, m_fmtTgt.chLayout.nb_channels, m_fmtTgt.freq, m_fmtTgt.fmt, 1);
 	if(m_fmtTgt.bytesPerSec <= 0 || m_fmtTgt.frameSize <= 0) {
 		av_log(nullptr, AV_LOG_ERROR, "av_samples_get_buffer_size failed\n");
 		close();
@@ -349,47 +355,44 @@ AudioDecoder::syncAudio(int nbSamples)
 int
 AudioDecoder::decodeFrame(Frame *af)
 {
+	// CONVERTED maxrd2
 	if(af->serial != m_queue->serial())
 		return -1;
 
-	int dataSize = av_samples_get_buffer_size(nullptr, af->frame->channels,
+	int dataSize = av_samples_get_buffer_size(nullptr, af->frame->ch_layout.nb_channels,
 										   af->frame->nb_samples,
 										   (AVSampleFormat)af->frame->format, 1);
 	int resampledDataSize;
 
-	uint64_t decChannelLayout =
-		(af->frame->channel_layout &&
-		 af->frame->channels == av_get_channel_layout_nb_channels(af->frame->channel_layout)) ?
-		af->frame->channel_layout : av_get_default_channel_layout(af->frame->channels);
 	int wantedNbSamples = syncAudio(af->frame->nb_samples);
 
 	if(af->frame->format != m_fmtSrc.fmt
-	|| decChannelLayout != m_fmtSrc.channelLayout
+	|| av_channel_layout_compare(&af->frame->ch_layout, &m_fmtSrc.chLayout)
 	|| af->frame->sample_rate != m_fmtSrc.freq
 	|| (wantedNbSamples != af->frame->nb_samples && !m_swrCtx)) {
 		swr_free(&m_swrCtx);
-		m_swrCtx = swr_alloc_set_opts(nullptr,
-										 m_fmtTgt.channelLayout, m_fmtTgt.fmt, m_fmtTgt.freq,
-										 decChannelLayout, (AVSampleFormat)af->frame->format, af->frame->sample_rate,
-										 0, nullptr);
-		if(!m_swrCtx || swr_init(m_swrCtx) < 0) {
+		int ret = swr_alloc_set_opts2(&m_swrCtx,
+							&m_fmtTgt.chLayout, m_fmtTgt.fmt, m_fmtTgt.freq,
+							&af->frame->ch_layout, AVSampleFormat(af->frame->format), af->frame->sample_rate,
+							0, nullptr);
+		if(ret < 0 || !m_swrCtx || swr_init(m_swrCtx) < 0) {
 			av_log(nullptr, AV_LOG_ERROR,
 				   "Cannot create sample rate converter for conversion of %d Hz %s %d channels to %d Hz %s %d channels!\n",
 				   af->frame->sample_rate, av_get_sample_fmt_name((AVSampleFormat)af->frame->format),
-				   af->frame->channels,
-				   m_fmtTgt.freq, av_get_sample_fmt_name(m_fmtTgt.fmt), m_fmtTgt.channels);
+				   af->frame->ch_layout.nb_channels,
+				   m_fmtTgt.freq, av_get_sample_fmt_name(m_fmtTgt.fmt), m_fmtTgt.chLayout.nb_channels);
 			swr_free(&m_swrCtx);
 			return -1;
 		}
-		m_fmtSrc.channelLayout = decChannelLayout;
-		m_fmtSrc.channels = af->frame->channels;
+		if(av_channel_layout_copy(&m_fmtSrc.chLayout, &af->frame->ch_layout) < 0)
+			return -1;
 		m_fmtSrc.freq = af->frame->sample_rate;
 		m_fmtSrc.fmt = (AVSampleFormat)af->frame->format;
 	}
 
 	if(m_swrCtx) {
 		const int outCount = (int64_t)wantedNbSamples * m_fmtTgt.freq / af->frame->sample_rate + 256;
-		const int outSize = av_samples_get_buffer_size(nullptr, m_fmtTgt.channels, outCount, m_fmtTgt.fmt, 0);
+		const int outSize = av_samples_get_buffer_size(nullptr, m_fmtTgt.chLayout.nb_channels, outCount, m_fmtTgt.fmt, 0);
 		if(outSize < 0) {
 			av_log(nullptr, AV_LOG_ERROR, "av_samples_get_buffer_size() failed\n");
 			return -1;
@@ -417,7 +420,7 @@ AudioDecoder::decodeFrame(Frame *af)
 				swr_free(&m_swrCtx);
 		}
 		m_audioBuf = m_audioBuf1;
-		resampledDataSize = outSamplesPerChannel * m_fmtTgt.channels * av_get_bytes_per_sample(m_fmtTgt.fmt);
+		resampledDataSize = outSamplesPerChannel * m_fmtTgt.chLayout.nb_channels * av_get_bytes_per_sample(m_fmtTgt.fmt);
 	} else {
 		m_audioBuf = af->frame->data[0];
 		resampledDataSize = dataSize;
@@ -487,8 +490,10 @@ AudioDecoder::run()
 			if(!(af->frame = av_frame_alloc()))
 				break;
 
+			Decoder::FrameData *fd = reinterpret_cast<Decoder::FrameData*>(frame->opaque_ref ? frame->opaque_ref->data : nullptr);
+
 			af->pts = frame->pts == AV_NOPTS_VALUE ? NAN : double(frame->pts) / frame->sample_rate;
-			af->pos = frame->pkt_pos;
+			af->pos = fd ? fd->pkt_pos : -1;
 			af->serial = m_pktSerial;
 			af->duration = double(frame->nb_samples) / frame->sample_rate;
 
diff -Naupr a/src/videoplayer/backend/audiodecoder.h n/src/videoplayer/backend/audiodecoder.h
--- a/src/videoplayer/backend/audiodecoder.h	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/audiodecoder.h	2024-08-11 03:49:35.000000000 +0200
@@ -37,8 +37,7 @@ private:
 
 	struct Params {
 		int freq;
-		int channels;
-		uint64_t channelLayout;
+		AVChannelLayout chLayout;
 		AVSampleFormat fmt;
 		int frameSize;
 		int bytesPerSec;
@@ -50,7 +49,7 @@ private:
 	void queueBuffer(uint8_t *data, int len);
 	int syncAudio(int nbSamples);
 
-	bool open(int64_t wanted_channel_layout, int wanted_nb_channels, int wanted_sample_rate);
+	bool open(AVChannelLayout *wantChLayout, int wantSampleRate);
 	void close();
 	void flush();
 	void play();
diff -Naupr a/src/videoplayer/backend/decoder.cpp n/src/videoplayer/backend/decoder.cpp
--- a/src/videoplayer/backend/decoder.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/decoder.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -133,10 +133,19 @@ Decoder::decodeFrame(AVFrame *frame, AVS
 			} else {
 				ret = pkt->data ? AVERROR(EAGAIN) : AVERROR_EOF;
 			}
-		} else if(avcodec_send_packet(m_avCtx, pkt) == AVERROR(EAGAIN)) {
-			av_log(m_avCtx, AV_LOG_ERROR, "Receive_frame and send_packet both returned EAGAIN, which is an API violation.\n");
-			m_pkt = pkt;
-			pkt = nullptr;
+		} else {
+			if(pkt->buf && !pkt->opaque_ref) {
+				pkt->opaque_ref = av_buffer_allocz(sizeof(Decoder::FrameData));
+				if(!pkt->opaque_ref)
+					return AVERROR(ENOMEM);
+				Decoder::FrameData *fd = reinterpret_cast<Decoder::FrameData*>(pkt->opaque_ref->data);
+				fd->pkt_pos = pkt->pos;
+			}
+			if(avcodec_send_packet(m_avCtx, pkt) == AVERROR(EAGAIN)) {
+				av_log(m_avCtx, AV_LOG_ERROR, "Receive_frame and send_packet both returned EAGAIN, which is an API violation.\n");
+				m_pkt = pkt;
+				pkt = nullptr;
+			}
 		}
 		av_packet_free(&pkt);
 	}
diff -Naupr a/src/videoplayer/backend/decoder.h n/src/videoplayer/backend/decoder.h
--- a/src/videoplayer/backend/decoder.h	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/decoder.h	2024-08-11 03:49:35.000000000 +0200
@@ -55,6 +55,10 @@ protected:
 	AVRational m_startPtsTb;
 	int64_t m_nextPts;
 	AVRational m_nextPtsTb;
+
+	struct FrameData {
+		int64_t pkt_pos;
+	};
 };
 }
 
diff -Naupr a/src/videoplayer/backend/renderthread.cpp n/src/videoplayer/backend/renderthread.cpp
--- a/src/videoplayer/backend/renderthread.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/renderthread.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -103,7 +103,7 @@ retry:
 
 			m_vs->vidFQ.m_mutex->lock();
 			if(!std::isnan(vp->pts))
-				updateVideoPts(vp->pts, vp->pos, vp->serial);
+				updateVideoPts(vp->pts, vp->serial);
 			m_vs->vidFQ.m_mutex->unlock();
 
 			if(m_vs->vidFQ.nbRemaining() > 1) {
@@ -187,7 +187,7 @@ RenderThread::vpDuration(Frame *vp, Fram
 }
 
 void
-RenderThread::updateVideoPts(double pts, int64_t /*pos*/, int serial)
+RenderThread::updateVideoPts(double pts, int serial)
 {
 	// update current video pts
 	m_vs->vidClk.set(pts, serial);
diff -Naupr a/src/videoplayer/backend/renderthread.h n/src/videoplayer/backend/renderthread.h
--- a/src/videoplayer/backend/renderthread.h	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/renderthread.h	2024-08-11 03:49:35.000000000 +0200
@@ -33,7 +33,7 @@ private:
 	void videoRefresh(double *remainingTime);
 	void videoDisplay();
 	double vpDuration(Frame *vp, Frame *nextvp);
-	void updateVideoPts(double pts, int64_t pos, int serial);
+	void updateVideoPts(double pts, int serial);
 	double computeTargetDelay(double delay);
 	void updateSampleDisplay(short *samples, int samplesSize);
 	void toggleAudioDisplay();
diff -Naupr a/src/videoplayer/backend/streamdemuxer.cpp n/src/videoplayer/backend/streamdemuxer.cpp
--- a/src/videoplayer/backend/streamdemuxer.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/streamdemuxer.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -233,9 +233,9 @@ StreamDemuxer::componentOpen(int streamI
 	AVCodecContext *avCtx;
 	const AVCodec *codec;
 	AVDictionary *opts = nullptr;
-	AVDictionaryEntry *t = nullptr;
-	int sampleRate, nbChannels;
-	int64_t channelLayout;
+	const AVDictionaryEntry *t = nullptr;
+	int sampleRate;
+	AVChannelLayout chLayout = {};
 	int ret = 0;
 	int stream_lowres = m_vs->lowres;
 
@@ -301,21 +301,21 @@ StreamDemuxer::componentOpen(int streamI
 	switch(avCtx->codec_type) {
 	case AVMEDIA_TYPE_AUDIO:
 		sampleRate = avCtx->sample_rate;
-		nbChannels = avCtx->channels;
-		channelLayout = avCtx->channel_layout;
+		if((ret = av_channel_layout_copy(&chLayout, &avCtx->ch_layout)) < 0) {
+			av_log(nullptr, AV_LOG_ERROR, "av_channel_layout_copy() failed (errL %d).\n", ret);
+			goto fail;
+		}
 
 		// prepare audio output
-		if(!m_vs->audDec.open(channelLayout, nbChannels, sampleRate))
+		if(!m_vs->audDec.open(&chLayout, sampleRate))
 			goto fail;
 
 		m_vs->audStreamIdx = streamIndex;
 		m_vs->audStream = ic->streams[streamIndex];
 
 		m_vs->audDec.init(avCtx, &m_vs->audPQ, nullptr, m_vs->continueReadThread);
-		if((m_vs->fmtContext->iformat->flags & (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &&
-		   !m_vs->fmtContext->iformat->read_seek) {
+		if(m_vs->fmtContext->iformat->flags & AVFMT_NOTIMESTAMPS)
 			m_vs->audDec.startPts(m_vs->audStream->start_time, m_vs->audStream->time_base);
-		}
 		m_vs->audDec.start();
 		m_vs->audDec.pause();
 		break;
@@ -342,6 +342,7 @@ StreamDemuxer::componentOpen(int streamI
 fail:
 	avcodec_free_context(&avCtx);
 out:
+	av_channel_layout_uninit(&chLayout);
 	av_dict_free(&opts);
 
 	return ret;
@@ -397,8 +398,7 @@ StreamDemuxer::cycleStream(int codecType
 			/* check that parameters are OK */
 			switch(codecType) {
 			case AVMEDIA_TYPE_AUDIO:
-				if(st->codecpar->sample_rate != 0 &&
-				   st->codecpar->channels != 0)
+				if(st->codecpar->sample_rate != 0 && st->codecpar->ch_layout.nb_channels != 0)
 					goto the_end;
 				break;
 			case AVMEDIA_TYPE_VIDEO:
@@ -501,8 +501,6 @@ StreamDemuxer::run()
 	if(m_vs->genpts)
 		ic->flags |= AVFMT_FLAG_GENPTS;
 
-	av_format_inject_global_side_data(ic);
-
 	{ // find_stream_info
 		const int origNbStreams = ic->nb_streams;
 		AVDictionary **opts = (AVDictionary **)av_calloc(origNbStreams, sizeof(*opts));
@@ -527,7 +525,7 @@ StreamDemuxer::run()
 		ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use avio_feof() to test for the end
 
 	if(m_vs->seek_by_bytes < 0)
-		m_vs->seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT) && strcmp("ogg", ic->iformat->name);
+		m_vs->seek_by_bytes = !(ic->iformat->flags & AVFMT_NO_BYTE_SEEK) && !!(ic->iformat->flags & AVFMT_TS_DISCONT) && strcmp("ogg", ic->iformat->name);
 
 	m_vs->maxFrameDuration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;
 
diff -Naupr a/src/videoplayer/backend/videodecoder.cpp n/src/videoplayer/backend/videodecoder.cpp
--- a/src/videoplayer/backend/videodecoder.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/videodecoder.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -101,8 +101,10 @@ VideoDecoder::run()
 		if(!ret)
 			continue;
 
+		Decoder::FrameData *fd = reinterpret_cast<Decoder::FrameData*>(frame->opaque_ref ? frame->opaque_ref->data : nullptr);
+
 		double pts = (frame->pts == AV_NOPTS_VALUE) ? NAN : frame->pts * m_timeBase;
-		ret = queuePicture(frame, pts, frameDuration, frame->pkt_pos, pktSerial());
+		ret = queuePicture(frame, pts, frameDuration, fd ? fd->pkt_pos : -1, pktSerial());
 		av_frame_unref(frame);
 
 		if(ret < 0)
diff -Naupr a/src/videoplayer/backend/videostate.cpp n/src/videoplayer/backend/videostate.cpp
--- a/src/videoplayer/backend/videostate.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/backend/videostate.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -131,7 +131,7 @@ VideoState::notifyLoaded()
 			continue;
 
 		*streamName += QStringLiteral(": ");
-		AVDictionaryEntry *tag = av_dict_get(stream->metadata, "lang", nullptr, AV_DICT_IGNORE_SUFFIX);
+		const AVDictionaryEntry *tag = av_dict_get(stream->metadata, "lang", nullptr, AV_DICT_IGNORE_SUFFIX);
 		*streamName += tag ? QString("%2 (%3)").arg(LanguageCode::nameFromIso(tag->value)).arg(tag->value) : QStringLiteral("Unknown");
 
 		if((tag = av_dict_get(stream->metadata, "title", nullptr, 0)) != nullptr)
diff -Naupr a/src/videoplayer/subtitletextoverlay.cpp n/src/videoplayer/subtitletextoverlay.cpp
--- a/src/videoplayer/subtitletextoverlay.cpp	2024-06-08 04:22:21.000000000 +0200
+++ n/src/videoplayer/subtitletextoverlay.cpp	2024-08-11 03:49:35.000000000 +0200
@@ -113,6 +113,8 @@ SubtitleTextOverlay::drawDocPrepare(QPai
 void
 SubtitleTextOverlay::drawDoc()
 {
+	if(m_image.isNull())
+		return;
 	QPainter painter(&m_image);
 	painter.setRenderHints(QPainter::Antialiasing | QPainter::TextAntialiasing | QPainter::SmoothPixmapTransform, true);
 	painter.setFont(m_font);
@@ -205,6 +207,7 @@ SubtitleTextOverlay::setText(const QStri
 {
 	if(!m_text) {
 		m_text = new RichDocument(this);
+		m_text->setStylesheet(new RichCSS(this));
 	} else if(m_text->toHtml() == text) {
 		return;
 	}
