diff -Naupr memcached-2.1.0/memcached-api.php memcached-master/memcached-api.php
--- memcached-2.1.0/memcached-api.php	2012-08-07 07:02:46.000000000 +0200
+++ memcached-master/memcached-api.php	2013-04-26 04:53:17.000000000 +0200
@@ -53,6 +53,8 @@ class Memcached {
 
 	const OPT_RETRY_TIMEOUT;
 
+	const OPT_DEAD_TIMEOUT;
+
 	const OPT_SND_TIMEOUT;
 
 	const OPT_RCV_TIMEOUT;
@@ -257,6 +259,14 @@ class Memcached {
 
 	public function getServerByKey( $server_key ) {}
 
+	public function getLastErrorMessage( ) {}
+
+	public function getLastErrorCode( ) {}
+
+	public function getLastErrorErrno( ) {}
+
+	public function getLastDisconnectedServer( ) {}
+
 	public function flush( $delay = 0 ) {}
 
 	public function getStats( ) {}
@@ -271,6 +281,8 @@ class Memcached {
 
 	public function isPristine( ) {}
 
+  public function setSaslAuthData( $username, $password ) {}
+
 }
 
 class MemcachedException extends Exception {
diff -Naupr memcached-2.1.0/memcached.ini memcached-master/memcached.ini
--- memcached-2.1.0/memcached.ini	2012-08-07 07:02:46.000000000 +0200
+++ memcached-master/memcached.ini	2013-04-26 04:53:17.000000000 +0200
@@ -17,9 +17,38 @@ memcached.sess_lock_wait = 150000
 ; the default value is "memc.sess.key."
 memcached.sess_prefix = "memc.sess.key."
 
+; memcached session consistent hash mode
+; if set to On, consistent hashing (libketama) is used
+; for session handling.
+; When consistent hashing is used, one can add or remove cache
+; node(s) without messing up too much with existing keys
+; default is Off
+memcached.sess_consistent_hash = Off
+
+; Allow failed memcached server to automatically be removed 
+memcached.sess_remove_failed = 1
+
+; Write data to a number of additional memcached servers
+; This is "poor man's HA" as libmemcached calls it.
+; If this value is positive and sess_remove_failed is enabled
+; when a memcached server fails the session will continue to be available
+; from a replica. However, if the failed memcache server
+; becomes available again it will read the session from there
+; which could have old data or no data at all
+memcached.sess_number_of_replicas = 0
+
 ; memcached session binary mode
+; libmemcached replicas only work if binary mode is enabled
 memcached.sess_binary = Off
 
+; memcached session replica read randomize
+memcached.sess_randomize_replica_read = Off
+
+; memcached connect timeout value
+; In non-blocking mode this changes the value of the timeout 
+; during socket connection in milliseconds. Specifying -1 means an infinite timeout.
+memcached.sess_connect_timeout = 1000
+
 ; Set the compression type
 ; valid values are: fastlz, zlib
 ; the default is fastlz
@@ -55,3 +84,7 @@ memcached.compression_threshold = 2000
 ; The default is igbinary if available and php otherwise.
 memcached.serializer = "igbinary"
 
+; Use SASL authentication for connections
+; valid values: On, Off
+; the default is Off
+memcached.use_sasl = Off
diff -Naupr memcached-2.1.0/php_memcached.c memcached-master/php_memcached.c
--- memcached-2.1.0/php_memcached.c	2012-08-07 07:02:46.000000000 +0200
+++ memcached-master/php_memcached.c	2013-04-26 04:53:17.000000000 +0200
@@ -264,7 +264,7 @@ static PHP_INI_MH(OnUpdateSerializer)
 		MEMC_G(serializer) = SERIALIZER_DEFAULT;
 	} else if (!strcmp(new_value, "php")) {
 		MEMC_G(serializer) = SERIALIZER_PHP;
-#ifdef HAVE_MEMCACHE_IGBINARY
+#ifdef HAVE_MEMCACHED_IGBINARY
 	} else if (!strcmp(new_value, "igbinary")) {
 		MEMC_G(serializer) = SERIALIZER_IGBINARY;
 #endif // IGBINARY
@@ -285,9 +285,15 @@ static PHP_INI_MH(OnUpdateSerializer)
 PHP_INI_BEGIN()
 #ifdef HAVE_MEMCACHED_SESSION
 	STD_PHP_INI_ENTRY("memcached.sess_locking",		"1",		PHP_INI_ALL, OnUpdateBool,		sess_locking_enabled,	zend_php_memcached_globals,	php_memcached_globals)
+	STD_PHP_INI_ENTRY("memcached.sess_consistent_hash",	"0",		PHP_INI_ALL, OnUpdateBool,		sess_consistent_hash_enabled,	zend_php_memcached_globals,	php_memcached_globals)
 	STD_PHP_INI_ENTRY("memcached.sess_binary",		"0",		PHP_INI_ALL, OnUpdateBool,		sess_binary_enabled,	zend_php_memcached_globals,	php_memcached_globals)
 	STD_PHP_INI_ENTRY("memcached.sess_lock_wait",		"150000",	PHP_INI_ALL, OnUpdateLongGEZero,sess_lock_wait,			zend_php_memcached_globals,	php_memcached_globals)
 	STD_PHP_INI_ENTRY("memcached.sess_prefix",		"memc.sess.key.",	PHP_INI_ALL, OnUpdateString, sess_prefix,		zend_php_memcached_globals,	php_memcached_globals)
+
+	STD_PHP_INI_ENTRY("memcached.sess_number_of_replicas",	"0",	PHP_INI_ALL, OnUpdateLongGEZero,	sess_number_of_replicas,	zend_php_memcached_globals,	php_memcached_globals)
+	STD_PHP_INI_ENTRY("memcached.sess_randomize_replica_read",	"0",	PHP_INI_ALL, OnUpdateBool,	sess_randomize_replica_read,	zend_php_memcached_globals,	php_memcached_globals)
+	STD_PHP_INI_ENTRY("memcached.sess_remove_failed",	"0",		PHP_INI_ALL, OnUpdateBool,              sess_remove_failed_enabled,	zend_php_memcached_globals,     php_memcached_globals)
+	STD_PHP_INI_ENTRY("memcached.sess_connect_timeout",     "1000",         PHP_INI_ALL, OnUpdateLong, 		sess_connect_timeout,           zend_php_memcached_globals,     php_memcached_globals)
 #endif
 	STD_PHP_INI_ENTRY("memcached.compression_type",		"fastlz",	PHP_INI_ALL, OnUpdateCompressionType, compression_type,		zend_php_memcached_globals,	php_memcached_globals)
 	STD_PHP_INI_ENTRY("memcached.compression_factor",	"1.3",		PHP_INI_ALL, OnUpdateReal, compression_factor,		zend_php_memcached_globals,	php_memcached_globals)
@@ -1170,6 +1176,7 @@ PHP_METHOD(Memcached, setMultiByKey)
 			case MEMCACHED_SERVER_MARKED_DEAD:	\
 				if (memcached_server_count(m_obj->memc) > 0) {	\
 					retry++;	\
+					i_obj->rescode = 0;	\
 					goto retry;	\
 				}	\
 				break;	\
@@ -1958,7 +1965,7 @@ PHP_METHOD(Memcached, getServerByKey)
 {
 	char *server_key;
 	int   server_key_len;
-	memcached_server_st *server;
+	memcached_server_instance_st *server_instance;
 	memcached_return error;
 	MEMC_METHOD_INIT_VARS;
 
@@ -1974,16 +1981,16 @@ PHP_METHOD(Memcached, getServerByKey)
 		RETURN_FALSE;
 	}
 
-	server = memcached_server_by_key(m_obj->memc, server_key, server_key_len, &error);
-	if (server == NULL) {
+	server_instance = memcached_server_by_key(m_obj->memc, server_key, server_key_len, &error);
+	if (server_instance == NULL) {
 		php_memc_handle_error(i_obj, error TSRMLS_CC);
 		RETURN_FALSE;
 	}
 
 	array_init(return_value);
-	add_assoc_string(return_value, "host", server->hostname, 1);
-	add_assoc_long(return_value, "port", server->port);
-	add_assoc_long(return_value, "weight", server->weight);
+	add_assoc_string(return_value, "host", (char*) memcached_server_name(server_instance), 1);
+	add_assoc_long(return_value, "port", memcached_server_port(server_instance));
+	add_assoc_long(return_value, "weight", 0);
 }
 /* }}} */
 
@@ -2021,6 +2028,81 @@ PHP_METHOD(Memcached, quit)
 }
 /* }}} */
 
+#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX >= 0x00049000
+/* {{{ Memcached::getLastErrorMessage()
+   Returns the last error message that occurred */
+PHP_METHOD(Memcached, getLastErrorMessage)
+{
+	MEMC_METHOD_INIT_VARS;
+
+	if (zend_parse_parameters_none() == FAILURE) {
+		return;
+	}
+
+	MEMC_METHOD_FETCH_OBJECT;
+
+	RETURN_STRING(memcached_last_error_message(m_obj->memc), 1);
+}
+/* }}} */
+
+/* {{{ Memcached::getLastErrorCode()
+   Returns the last error code that occurred */
+PHP_METHOD(Memcached, getLastErrorCode)
+{
+	MEMC_METHOD_INIT_VARS;
+
+	if (zend_parse_parameters_none() == FAILURE) {
+		return;
+	}
+
+	MEMC_METHOD_FETCH_OBJECT;
+
+	RETURN_LONG(memcached_last_error(m_obj->memc));
+}
+/* }}} */
+
+/* {{{ Memcached::getLastErrorErrno()
+   Returns the last error errno that occurred */
+PHP_METHOD(Memcached, getLastErrorErrno)
+{
+	MEMC_METHOD_INIT_VARS;
+
+	if (zend_parse_parameters_none() == FAILURE) {
+		return;
+	}
+
+	MEMC_METHOD_FETCH_OBJECT;
+
+	RETURN_LONG(memcached_last_error_errno(m_obj->memc));
+}
+/* }}} */
+#endif
+
+/* {{{ Memcached::getLastDisconnectedServer()
+   Returns the last disconnected server
+   Was added in 0.34 according to libmemcached's Changelog */
+PHP_METHOD(Memcached, getLastDisconnectedServer)
+{
+	memcached_server_instance_st *server_instance;
+	MEMC_METHOD_INIT_VARS;
+
+	if (zend_parse_parameters_none() == FAILURE) {
+		return;
+	}
+
+	MEMC_METHOD_FETCH_OBJECT;
+
+	server_instance = memcached_server_get_last_disconnect(m_obj->memc);
+	if (server_instance == NULL) {
+		RETURN_FALSE;
+	}
+
+	array_init(return_value);
+	add_assoc_string(return_value, "host", (char*) memcached_server_name(server_instance), 1);
+	add_assoc_long(return_value, "port", memcached_server_port(server_instance));
+}
+/* }}} */
+
 /* {{{ Memcached::getStats()
    Returns statistics for the memcache servers */
 PHP_METHOD(Memcached, getStats)
@@ -2175,7 +2257,7 @@ static PHP_METHOD(Memcached, getOption)
 
 			result = memcached_callback_get(m_obj->memc, MEMCACHED_CALLBACK_PREFIX_KEY, &retval);
 			if (retval == MEMCACHED_SUCCESS && result) {
-#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX < 0x00050000
+#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX == 0x00049000
 				RETURN_STRINGL(result, strlen(result) - 1,  1);
 #else
 				RETURN_STRING(result, 1);
@@ -2232,7 +2314,7 @@ static int php_memc_set_option(php_memc_
 		case MEMC_OPT_PREFIX_KEY:
 		{
 			char *key;
-#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX < 0x00050000
+#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX == 0x00049000
 			char tmp[MEMCACHED_PREFIX_KEY_MAX_SIZE - 1];
 #endif
 			convert_to_string(value);
@@ -2240,10 +2322,10 @@ static int php_memc_set_option(php_memc_
 				key = NULL;
 			} else {
 				/*
-				   work-around a bug in libmemcached prior to version 0.50 that truncates the trailing
+				   work-around a bug in libmemcached in version 0.49 that truncates the trailing
 				   character of the key prefix, to avoid the issue we pad it with a '0'
 				*/
-#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX < 0x00050000
+#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX == 0x00049000
 				snprintf(tmp, sizeof(tmp), "%s0", Z_STRVAL_P(value));
 				key = tmp;
 #else
@@ -2406,6 +2488,11 @@ static PHP_METHOD(Memcached, setSaslAuth
 		return;
 	}
 
+	if (!MEMC_G(use_sasl)) {
+		php_error_docref(NULL TSRMLS_CC, E_WARNING, "SASL support (memcached.use_sasl) isn't enabled in php.ini");
+		RETURN_FALSE;
+	}
+
 	MEMC_METHOD_FETCH_OBJECT;
 
 	if (!memcached_behavior_get(m_obj->memc, MEMCACHED_BEHAVIOR_BINARY_PROTOCOL)) {
@@ -2580,12 +2667,13 @@ static memcached_return php_memc_do_serv
 
 	MAKE_STD_ZVAL(array);
 	array_init(array);
-	add_assoc_string(array, "host", memcached_server_name(instance), 1);
+	add_assoc_string(array, "host", (char*) memcached_server_name(instance), 1);
 	add_assoc_long(array, "port", memcached_server_port(instance));
 	/*
 	 * API does not allow to get at this field.
 	add_assoc_long(array, "weight", instance->weight);
-	 */
+	*/
+
 	add_next_index_zval(context->return_value, array);
 	return MEMCACHED_SUCCESS;
 }
@@ -2642,10 +2730,17 @@ static memcached_return php_memc_do_vers
 	struct callbackContext* context = (struct callbackContext*) in_context;
 
 	hostport_len = spprintf(&hostport, 0, "%s:%d", memcached_server_name(instance), memcached_server_port(instance));
+#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX >= 0x01000009
 	version_len = snprintf(version, sizeof(version), "%d.%d.%d",
 				memcached_server_major_version(instance),
 				memcached_server_minor_version(instance),
 				memcached_server_micro_version(instance));
+#else
+	version_len = snprintf(version, sizeof(version), "%d.%d.%d",
+				instance->major_version,
+				instance->minor_version,
+				instance->micro_version);
+#endif
 
 	add_assoc_stringl_ex(context->return_value, hostport, hostport_len+1, version, version_len, 1);
 	efree(hostport);
@@ -3027,11 +3122,16 @@ static void php_memc_init_globals(zend_p
 #ifdef HAVE_MEMCACHED_SESSION
 	MEMC_G(sess_locking_enabled) = 1;
 	MEMC_G(sess_binary_enabled) = 1;
+	MEMC_G(sess_consistent_hash_enabled) = 0;
+	MEMC_G(sess_number_of_replicas) = 0;
+	MEMC_G(sess_remove_failed_enabled) = 0;
 	MEMC_G(sess_prefix) = NULL;
 	MEMC_G(sess_lock_wait) = 0;
 	MEMC_G(sess_locked) = 0;
 	MEMC_G(sess_lock_key) = NULL;
 	MEMC_G(sess_lock_key_len) = 0;
+	MEMC_G(sess_randomize_replica_read) = 0;
+	MEMC_G(sess_connect_timeout) = 1000;
 #endif
 	MEMC_G(serializer_name) = NULL;
 	MEMC_G(serializer) = SERIALIZER_DEFAULT;
@@ -3466,6 +3566,18 @@ ZEND_BEGIN_ARG_INFO(arginfo_getServerByK
 	ZEND_ARG_INFO(0, server_key)
 ZEND_END_ARG_INFO()
 
+ZEND_BEGIN_ARG_INFO(arginfo_getLastErrorMessage, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_getLastErrorCode, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_getLastErrorErrno, 0)
+ZEND_END_ARG_INFO()
+
+ZEND_BEGIN_ARG_INFO(arginfo_getLastDisconnectedServer, 0)
+ZEND_END_ARG_INFO()
+
 ZEND_BEGIN_ARG_INFO(arginfo_getOption, 0)
 	ZEND_ARG_INFO(0, option)
 ZEND_END_ARG_INFO()
@@ -3553,6 +3665,13 @@ static zend_function_entry memcached_cla
     MEMC_ME(resetServerList,    arginfo_resetServerList)
     MEMC_ME(quit,               arginfo_quit)
 
+#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX >= 0x00049000
+	MEMC_ME(getLastErrorMessage,		arginfo_getLastErrorMessage)
+	MEMC_ME(getLastErrorCode,		arginfo_getLastErrorCode)
+	MEMC_ME(getLastErrorErrno,		arginfo_getLastErrorErrno)
+#endif
+	MEMC_ME(getLastDisconnectedServer,	arginfo_getLastDisconnectedServer)
+
 	MEMC_ME(getStats,           arginfo_getStats)
 	MEMC_ME(getVersion,         arginfo_getVersion)
 	MEMC_ME(getAllKeys,         arginfo_getAllKeys)
@@ -3691,6 +3810,9 @@ static void php_memc_register_constants(
 	REGISTER_MEMC_CLASS_CONST_LONG(OPT_SOCKET_RECV_SIZE, MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE);
 	REGISTER_MEMC_CLASS_CONST_LONG(OPT_CONNECT_TIMEOUT, MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT);
 	REGISTER_MEMC_CLASS_CONST_LONG(OPT_RETRY_TIMEOUT, MEMCACHED_BEHAVIOR_RETRY_TIMEOUT);
+#if defined(LIBMEMCACHED_VERSION_HEX) && LIBMEMCACHED_VERSION_HEX >= 0x01000003
+	REGISTER_MEMC_CLASS_CONST_LONG(OPT_DEAD_TIMEOUT, MEMCACHED_BEHAVIOR_DEAD_TIMEOUT);
+#endif
 	REGISTER_MEMC_CLASS_CONST_LONG(OPT_SEND_TIMEOUT, MEMCACHED_BEHAVIOR_SND_TIMEOUT);
 	REGISTER_MEMC_CLASS_CONST_LONG(OPT_RECV_TIMEOUT, MEMCACHED_BEHAVIOR_RCV_TIMEOUT);
 	REGISTER_MEMC_CLASS_CONST_LONG(OPT_POLL_TIMEOUT, MEMCACHED_BEHAVIOR_POLL_TIMEOUT);
@@ -3870,6 +3992,12 @@ PHP_MINFO_FUNCTION(memcached)
 	php_info_print_table_row(2, "Version", PHP_MEMCACHED_VERSION);
 	php_info_print_table_row(2, "libmemcached version", memcached_lib_version());
 
+#if HAVE_MEMCACHED_SASL
+	php_info_print_table_row(2, "SASL support", "yes");
+#else
+	php_info_print_table_row(2, "SASL support", "no");
+#endif
+
 #ifdef HAVE_MEMCACHED_SESSION
 	php_info_print_table_row(2, "Session support", "yes");
 #else
diff -Naupr memcached-2.1.0/php_memcached.h memcached-master/php_memcached.h
--- memcached-2.1.0/php_memcached.h	2012-08-07 07:02:46.000000000 +0200
+++ memcached-master/php_memcached.h	2013-04-26 04:53:17.000000000 +0200
@@ -66,6 +66,13 @@ ZEND_BEGIN_MODULE_GLOBALS(php_memcached)
 	zend_bool sess_locked;
 	char* sess_lock_key;
 	int   sess_lock_key_len;
+
+	int   sess_number_of_replicas;
+	zend_bool sess_randomize_replica_read;
+	zend_bool sess_remove_failed_enabled;
+	long  sess_connect_timeout;
+	zend_bool sess_consistent_hash_enabled;
+	zend_bool sess_binary_enabled;
 #endif
 	char *serializer_name;
 	enum memcached_serializer serializer;
@@ -78,7 +85,6 @@ ZEND_BEGIN_MODULE_GLOBALS(php_memcached)
 #if HAVE_MEMCACHED_SASL
 	bool use_sasl;
 #endif
-	zend_bool sess_binary_enabled;
 ZEND_END_MODULE_GLOBALS(php_memcached)
 
 PHP_MEMCACHED_API zend_class_entry *php_memc_get_ce(void);
diff -Naupr memcached-2.1.0/php_memcached_session.c memcached-master/php_memcached_session.c
--- memcached-2.1.0/php_memcached_session.c	2012-08-07 07:02:46.000000000 +0200
+++ memcached-master/php_memcached_session.c	2013-04-26 04:53:17.000000000 +0200
@@ -48,6 +48,7 @@ static int php_memc_sess_lock(memcached_
 	char *lock_key = NULL;
 	int lock_key_len = 0;
 	unsigned long attempts;
+	long write_retry_attempts = 0;
 	long lock_maxwait;
 	long lock_wait = MEMC_G(sess_lock_wait);
 	time_t expiration;
@@ -64,6 +65,11 @@ static int php_memc_sess_lock(memcached_
 	expiration  = time(NULL) + lock_maxwait + 1;
 	attempts = (unsigned long)((1000000.0 / lock_wait) * lock_maxwait);
 
+	/* Set the number of write retry attempts to the number of replicas times the number of attempts to remove a server */
+	if (MEMC_G(sess_remove_failed_enabled)) {
+		write_retry_attempts = MEMC_G(sess_number_of_replicas) * ( memcached_behavior_get(memc, MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT) + 1);
+	}
+
 	lock_key_len = spprintf(&lock_key, 0, "lock.%s", key);
 	do {
 		status = memcached_add(memc, lock_key, lock_key_len, "1", sizeof("1")-1, expiration, 0);
@@ -73,6 +79,11 @@ static int php_memc_sess_lock(memcached_
 			MEMC_G(sess_lock_key_len) = lock_key_len;
 			return 0;
 		} else if (status != MEMCACHED_NOTSTORED && status != MEMCACHED_DATA_EXISTS) {
+			if (write_retry_attempts > 0) {
+				write_retry_attempts--;
+				continue;
+			}
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Write of lock failed");
 			break;
 		}
 
@@ -139,10 +150,22 @@ error:
 		if (servers) {
 			memc_sess->memc_sess = memcached_create(NULL);
 			if (memc_sess->memc_sess) {
+				if (MEMC_G(sess_consistent_hash_enabled)) {
+					if (memcached_behavior_set(memc_sess->memc_sess, MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED, (uint64_t) 1) == MEMCACHED_FAILURE) {
+						PS_SET_MOD_DATA(NULL);
+						if (plist_key) {
+							efree(plist_key);
+						}
+						memcached_free(memc_sess->memc_sess);
+						php_error_docref(NULL TSRMLS_CC, E_WARNING, "failed to enable memcached consistent hashing");
+						return FAILURE;
+					}
+				}
+
 				status = memcached_server_push(memc_sess->memc_sess, servers);
 				memcached_server_list_free(servers);
 
-				if (memcached_callback_set(memc_sess->memc_sess, MEMCACHED_CALLBACK_PREFIX_KEY, MEMC_G(sess_prefix)) != MEMCACHED_SUCCESS) {
+				if (MEMC_G(sess_prefix) && MEMC_G(sess_prefix)[0] != 0 && memcached_callback_set(memc_sess->memc_sess, MEMCACHED_CALLBACK_PREFIX_KEY, MEMC_G(sess_prefix)) != MEMCACHED_SUCCESS) {
 					PS_SET_MOD_DATA(NULL);
 					if (plist_key) {
 						efree(plist_key);
@@ -195,6 +218,29 @@ success:
 				}
 			}
 
+			if (MEMC_G(sess_number_of_replicas) > 0) {
+				if (memcached_behavior_set(memc_sess->memc_sess, MEMCACHED_BEHAVIOR_NUMBER_OF_REPLICAS, (uint64_t) MEMC_G(sess_number_of_replicas)) == MEMCACHED_FAILURE) {
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "failed to set memcached session number of replicas");
+					return FAILURE;
+				}
+				if (memcached_behavior_set(memc_sess->memc_sess, MEMCACHED_BEHAVIOR_RANDOMIZE_REPLICA_READ, (uint64_t) MEMC_G(sess_randomize_replica_read)) == MEMCACHED_FAILURE) {
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "failed to set memcached session randomize replica read");
+				}
+			}
+
+			if (memcached_behavior_set(memc_sess->memc_sess, MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT, (uint64_t) MEMC_G(sess_connect_timeout)) == MEMCACHED_FAILURE) {
+				php_error_docref(NULL TSRMLS_CC, E_WARNING, "failed to set memcached connection timeout");
+				return FAILURE;
+			}
+
+			/* Allow libmemcached remove failed servers */
+			if (MEMC_G(sess_remove_failed_enabled)) {
+				if (memcached_behavior_set(memc_sess->memc_sess, MEMCACHED_BEHAVIOR_REMOVE_FAILED_SERVERS, (uint64_t) 1) == MEMCACHED_FAILURE) {
+					php_error_docref(NULL TSRMLS_CC, E_WARNING, "failed to set: remove failed servers");
+					return FAILURE;
+				}
+			}
+
 			return SUCCESS;
 		}
 	}
@@ -243,6 +289,7 @@ PS_READ_FUNC(memcached)
 
 	if (MEMC_G(sess_locking_enabled)) {
 		if (php_memc_sess_lock(memc_sess->memc_sess, key TSRMLS_CC) < 0) {
+			php_error_docref(NULL TSRMLS_CC, E_WARNING, "Unable to clear session lock record");
 			return FAILURE;
 		}
 	}
@@ -263,6 +310,7 @@ PS_WRITE_FUNC(memcached)
 {
 	int key_len = strlen(key);
 	time_t expiration = 0;
+	long write_try_attempts = 1;
 	memcached_return status;
 	memcached_sess *memc_sess = PS_GET_MOD_DATA();
 	size_t key_length;
@@ -277,13 +325,22 @@ PS_WRITE_FUNC(memcached)
 	if (PS(gc_maxlifetime) > 0) {
 		expiration = PS(gc_maxlifetime);
 	}
-	status = memcached_set(memc_sess->memc_sess, key, key_len, val, vallen, expiration, 0);
 
-	if (status == MEMCACHED_SUCCESS) {
-		return SUCCESS;
-	} else {
-		return FAILURE;
+	/* Set the number of write retry attempts to the number of replicas times the number of attempts to remove a server plus the initial write */
+	if (MEMC_G(sess_remove_failed_enabled)) {
+		write_try_attempts = 1 + MEMC_G(sess_number_of_replicas) * ( memcached_behavior_get(memc_sess->memc_sess, MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT) + 1);
 	}
+
+	do {
+		status = memcached_set(memc_sess->memc_sess, key, key_len, val, vallen, expiration, 0);
+		if (status == MEMCACHED_SUCCESS) {
+			return SUCCESS;
+		} else {
+			write_try_attempts--;
+		}
+	} while (write_try_attempts > 0);
+
+	return FAILURE;
 }
 
 PS_DESTROY_FUNC(memcached)
