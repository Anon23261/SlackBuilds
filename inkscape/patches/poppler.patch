--- a/src/extension/internal/pdfinput/pdf-input.cpp	2023-11-16 20:05:21.000000000 +0100
+++ b/src/extension/internal/pdfinput/pdf-input.cpp	2024-05-23 14:17:28.669307494 +0200
@@ -35,29 +35,37 @@
 #include <poppler/glib/poppler-page.h>
 #endif
 
+#include <utility>
 #include <gdkmm/general.h>
 #include <glibmm/convert.h>
 #include <glibmm/i18n.h>
 #include <glibmm/miscutils.h>
-#include <gtk/gtk.h>
+#include <gtkmm/builder.h>
+#include <gtkmm/button.h>
+#include <gtkmm/cellrenderercombo.h>
 #include <gtkmm/checkbutton.h>
 #include <gtkmm/comboboxtext.h>
 #include <gtkmm/drawingarea.h>
+#include <gtkmm/entry.h>
 #include <gtkmm/frame.h>
-#include <gtkmm/radiobutton.h>
+#include <gtkmm/label.h>
+#include <gtkmm/liststore.h>
+#include <gtkmm/notebook.h>
 #include <gtkmm/scale.h>
-#include <utility>
 
+#include "async/async.h"
+#include "document.h"
 #include "document-undo.h"
 #include "extension/input.h"
 #include "extension/system.h"
 #include "inkscape.h"
-#include "object/sp-root.h"
 #include "pdf-parser.h"
+#include "object/sp-root.h"
 #include "ui/builder-utils.h"
 #include "ui/dialog-events.h"
-#include "ui/widget/frame.h"
-#include "ui/widget/spinbutton.h"
+#include "ui/dialog-run.h"
+#include "ui/pack.h"
+#include "util/gobjectptr.h"
 #include "util/parse-int-range.h"
 #include "util/units.h"
 
@@ -131,31 +139,27 @@ PdfImportDialog::PdfImportDialog(std::sh
 
     _setFonts(getPdfFonts(_pdf_doc));
 
-    auto okbutton = Gtk::manage(new Gtk::Button(_("_OK"), true));
+    auto const okbutton = Gtk::make_managed<Gtk::Button>(_("_OK"), true);
 
     get_content_area()->set_homogeneous(false);
     get_content_area()->set_spacing(0);
-
-    get_content_area()->pack_start(UI::get_widget<Gtk::Box>(_builder, "content"));
+    UI::pack_start(*get_content_area(), UI::get_widget<Gtk::Box>(_builder, "content"));
 
     this->set_title(_("PDF Import Settings"));
     this->set_modal(true);
-    sp_transientize(GTK_WIDGET(this->gobj()));  //Make transient
-    this->property_window_position().set_value(Gtk::WIN_POS_NONE);
+    sp_transientize(*this);
     this->set_resizable(true);
     this->property_destroy_with_parent().set_value(false);
 
-    this->add_action_widget(*Gtk::manage(new Gtk::Button(_("_Cancel"), true)), -6);
+    this->add_action_widget(*Gtk::make_managed<Gtk::Button>(_("_Cancel"), true), -6);
     this->add_action_widget(*okbutton, -5);
 
-    this->show_all();
-
     _render_thumb = false;
 
     // Connect signals
-    _next_page.signal_clicked().connect([=] { _setPreviewPage(_preview_page + 1); });
-    _prev_page.signal_clicked().connect([=] { _setPreviewPage(_preview_page - 1); });
-    _preview_area.signal_draw().connect(sigc::mem_fun(*this, &PdfImportDialog::_onDraw));
+    _next_page.signal_clicked().connect([this] { _setPreviewPage(_preview_page + 1); });
+    _prev_page.signal_clicked().connect([this] { _setPreviewPage(_preview_page - 1); });
+    _preview_area.set_draw_func(sigc::mem_fun(*this, &PdfImportDialog::_drawFunc));
     _page_numbers.signal_changed().connect(sigc::mem_fun(*this, &PdfImportDialog::_onPageNumberChanged));
     _mesh_slider.get_adjustment()->signal_value_changed().connect(
         sigc::mem_fun(*this, &PdfImportDialog::_onPrecisionChanged));
@@ -182,19 +186,19 @@ PdfImportDialog::PdfImportDialog(std::sh
     // Set default preview size
     _preview_width = 200;
     _preview_height = 300;
+    _preview_area.set_size_request(_preview_width, _preview_height);
 
     // Init preview
     _thumb_data = nullptr;
     _current_pages = "all";
     _setPreviewPage(1);
 
-    okbutton->set_can_focus();
-    okbutton->set_can_default();
-    set_default(*okbutton);
+    okbutton->set_focusable();
+    set_default_widget(*okbutton);
     set_focus(*okbutton);
 
     auto &font_strat = UI::get_object_raw<Gtk::CellRendererCombo>(_builder, "cell-strat");
-    font_strat.signal_changed().connect([=](const Glib::ustring &path, const Gtk::TreeModel::iterator &source) {
+    font_strat.signal_changed().connect([this](const Glib::ustring &path, const Gtk::TreeModel::iterator &source) {
         if (auto target = _font_model->get_iter(path)) {
             (*target)[_font_col->proc_id] = int((*source)[_font_col->id]);
             (*target)[_font_col->proc_label] = Glib::ustring((*source)[_font_col->family]);
@@ -208,9 +212,6 @@ PdfImportDialog::PdfImportDialog(std::sh
 
 PdfImportDialog::~PdfImportDialog() {
 #ifdef HAVE_POPPLER_CAIRO
-    if (_cairo_surface) {
-        cairo_surface_destroy(_cairo_surface);
-    }
     if (_poppler_doc) {
         g_object_unref(G_OBJECT(_poppler_doc));
     }
@@ -221,10 +222,8 @@ PdfImportDialog::~PdfImportDialog() {
 }
 
 bool PdfImportDialog::showDialog() {
-    show();
-    gint b = run();
-    hide();
-    if ( b == Gtk::RESPONSE_OK ) {
+    gint b = UI::dialog_run(*this);
+    if ( b == Gtk::ResponseType::OK ) {
         return TRUE;
     } else {
         return FALSE;
@@ -377,7 +376,6 @@ void PdfImportDialog::setFontStrategies(
  *
  */
 static void copy_cairo_surface_to_pixbuf (cairo_surface_t *surface,
-                                          unsigned char   *data,
                                           GdkPixbuf       *pixbuf)
 {
     int cairo_width, cairo_height, cairo_rowstride;
@@ -388,8 +386,8 @@ static void copy_cairo_surface_to_pixbuf
 
     cairo_width = cairo_image_surface_get_width (surface);
     cairo_height = cairo_image_surface_get_height (surface);
-    cairo_rowstride = cairo_width * 4;
-    cairo_data = data;
+    cairo_rowstride = cairo_image_surface_get_stride(surface);
+    cairo_data = cairo_image_surface_get_data(surface);
 
     pixbuf_data = gdk_pixbuf_get_pixels (pixbuf);
     pixbuf_rowstride = gdk_pixbuf_get_rowstride (pixbuf);
@@ -418,24 +416,25 @@ static void copy_cairo_surface_to_pixbuf
 
 #endif
 
-bool PdfImportDialog::_onDraw(const Cairo::RefPtr<Cairo::Context>& cr) {
+void PdfImportDialog::_drawFunc(const Cairo::RefPtr<Cairo::Context>& cr, int const width, int const height)
+{
     // Check if we have a thumbnail at all
-    if (!_thumb_data) {
-        return true;
+    if (!_thumb_data && !_cairo_surfaces[_preview_page]) {
+        return;
     }
 
     // Create the pixbuf for the thumbnail
     Glib::RefPtr<Gdk::Pixbuf> thumb;
 
     if (_render_thumb) {
-        thumb = Gdk::Pixbuf::create(Gdk::COLORSPACE_RGB, true,
+        thumb = Gdk::Pixbuf::create(Gdk::Colorspace::RGB, true,
                                     8, _thumb_width, _thumb_height);
-    } else {
-        thumb = Gdk::Pixbuf::create_from_data(_thumb_data, Gdk::COLORSPACE_RGB,
+    } else if (_thumb_data) {
+        thumb = Gdk::Pixbuf::create_from_data(_thumb_data, Gdk::Colorspace::RGB,
             false, 8, _thumb_width, _thumb_height, _thumb_rowstride);
     }
     if (!thumb) {
-        return true;
+        return;
     }
 
     // Set background to white
@@ -444,16 +443,16 @@ bool PdfImportDialog::_onDraw(const Cair
 	Gdk::Cairo::set_source_pixbuf(cr, thumb, 0, 0);
 	cr->paint();
     }
+
 #ifdef HAVE_POPPLER_CAIRO
     // Copy the thumbnail image from the Cairo surface
     if (_render_thumb) {
-        copy_cairo_surface_to_pixbuf(_cairo_surface, _thumb_data, thumb->gobj());
+        copy_cairo_surface_to_pixbuf(_cairo_surfaces[_preview_page].get(), thumb->gobj());
     }
 #endif
 
     Gdk::Cairo::set_source_pixbuf(cr, thumb, 0, _render_thumb ? 0 : 20);
     cr->paint();
-    return true;
 }
 
 /**
@@ -511,30 +510,45 @@ void PdfImportDialog::_setPreviewPage(in
     // Create new Cairo surface
     _thumb_width = (int)ceil( width * scale_factor );
     _thumb_height = (int)ceil( height * scale_factor );
-    _thumb_rowstride = _thumb_width * 4;
-    if (_thumb_data) {
-        gfree(_thumb_data);
-    }
-    _thumb_data = reinterpret_cast<unsigned char *>(gmalloc(_thumb_rowstride * _thumb_height));
-    if (_cairo_surface) {
-        cairo_surface_destroy(_cairo_surface);
-    }
-    _cairo_surface = cairo_image_surface_create_for_data(_thumb_data,
-            CAIRO_FORMAT_ARGB32, _thumb_width, _thumb_height, _thumb_rowstride);
-    cairo_t *cr = cairo_create(_cairo_surface);
-    cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 1.0);  // Set fill color to white
-    cairo_paint(cr);    // Clear it
-    cairo_scale(cr, scale_factor, scale_factor);    // Use Cairo for resizing the image
-    // Render page
-    if (_poppler_doc != NULL) {
-        PopplerPage *poppler_page = poppler_document_get_page(_poppler_doc, page-1);
-        poppler_page_render(poppler_page, cr);
-        g_object_unref(G_OBJECT(poppler_page));
+    if (_poppler_doc && !_cairo_surfaces[page] && !_preview_rendering_in_progress) {
+        // poppler_page_render() isn't safe to call concurrently for multiple
+        // pages, so we render at most one page at a time. We'll restart
+        // rendering in "onfinish" if necessary.
+        _preview_rendering_in_progress = true;
+
+        // Render page asynchronously in a separate thread. The dialog will
+        // become available and responsive even if the rendering takes longer.
+
+        auto cairo_surface = std::shared_ptr<cairo_surface_t>(
+            cairo_image_surface_create(CAIRO_FORMAT_ARGB32, _thumb_width, _thumb_height), //
+            cairo_surface_destroy);
+
+        auto poppler_page = Util::GObjectPtr(poppler_document_get_page(_poppler_doc, page - 1));
+
+        auto [src, dst] = Async::Channel::create();
+
+        Async::fire_and_forget([cairo_surface, scale_factor, poppler_page = std::move(poppler_page),
+                                channel = std::move(src), dialog = this, page]() mutable {
+            cairo_t *cr = cairo_create(cairo_surface.get());
+            cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 1.0); // Set fill color to white
+            cairo_paint(cr);                               // Clear it
+            cairo_scale(cr, scale_factor, scale_factor);   // Use Cairo for resizing the image
+            poppler_page_render(poppler_page.get(), cr);
+            cairo_destroy(cr);
+            channel.run([=] {
+                dialog->_preview_rendering_in_progress = false;
+                dialog->_preview_area.queue_draw();
+                if (dialog->_preview_page != page) {
+                    // Restart rendering for the current page
+                    dialog->_setPreviewPage(dialog->_preview_page);
+                }
+            });
+        });
+
+        _channels.push_back(std::move(dst));
+        _cairo_surfaces[page] = std::move(cairo_surface);
     }
-    // Clean up
-    cairo_destroy(cr);
     // Redraw preview area
-    _preview_area.set_size_request(_preview_width, _preview_height);
     _preview_area.queue_draw();
 #endif
 }
@@ -556,15 +570,13 @@ static cairo_status_t
 /**
  * Parses the selected page of the given PDF document using PdfParser.
  */
-SPDocument *
-PdfInput::open(::Inkscape::Extension::Input * /*mod*/, const gchar * uri) {
-
+std::unique_ptr<SPDocument> PdfInput::open(Inkscape::Extension::Input *, char const *uri)
+{
     // Initialize the globalParams variable for poppler
     if (!globalParams) {
         globalParams = _POPPLER_NEW_GLOBAL_PARAMS();
     }
 
-
     // Open the file using poppler
     // PDFDoc is from poppler. PDFDoc is used for preview and for native import.
     std::shared_ptr<PDFDoc> pdf_doc;
@@ -602,10 +614,9 @@ PdfInput::open(::Inkscape::Extension::In
         return nullptr;
     }
 
-
-    std::unique_ptr<PdfImportDialog> dlg;
+    std::optional<PdfImportDialog> dlg;
     if (INKSCAPE.use_gui()) {
-        dlg = std::make_unique<PdfImportDialog>(pdf_doc, uri);
+        dlg.emplace(pdf_doc, uri);
         if (!dlg->showDialog()) {
             throw Input::open_cancelled();
         }
@@ -635,13 +646,13 @@ PdfInput::open(::Inkscape::Extension::In
     }
 
     // Create Inkscape document from file
-    SPDocument *doc = nullptr;
+    std::unique_ptr<SPDocument> doc;
     bool saved = false;
     if (import_method == PdfImportType::PDF_IMPORT_INTERNAL) {
         // Create document
         doc = SPDocument::createNewDoc(nullptr, true, true);
-        saved = DocumentUndo::getUndoSensitive(doc);
-        DocumentUndo::setUndoSensitive(doc, false); // No need to undo in this temporary document
+        saved = DocumentUndo::getUndoSensitive(doc.get());
+        DocumentUndo::setUndoSensitive(doc.get(), false); // No need to undo in this temporary document
 
         // Create builder
         gchar *docname = g_path_get_basename(uri);
@@ -649,7 +660,7 @@ PdfInput::open(::Inkscape::Extension::In
         if (dot) {
             *dot = 0;
         }
-        SvgBuilder *builder = new SvgBuilder(doc, docname, pdf_doc->getXRef());
+        SvgBuilder *builder = new SvgBuilder(doc.get(), docname, pdf_doc->getXRef());
         builder->setFontStrategies(font_strats);
 
         // Get preferences
@@ -659,7 +670,7 @@ PdfInput::open(::Inkscape::Extension::In
 
         for (auto p : pages) {
             // And then add each of the pages
-            add_builder_page(pdf_doc, builder, doc, p);
+            add_builder_page(pdf_doc, builder, doc.get(), p);
         }
 
         delete builder;
@@ -711,7 +722,7 @@ PdfInput::open(::Inkscape::Extension::In
             cairo_destroy(cr);
             cairo_surface_destroy(surface);
 
-            doc = SPDocument::createNewDocFromMem(output.c_str(), output.length(), TRUE);
+            doc = SPDocument::createNewDocFromMem(output.raw(), true);
 
             g_object_unref(G_OBJECT(page));
         } else if (document) {
@@ -723,8 +734,8 @@ PdfInput::open(::Inkscape::Extension::In
             return nullptr;
         }
 
-        saved = DocumentUndo::getUndoSensitive(doc);
-        DocumentUndo::setUndoSensitive(doc, false); // No need to undo in this temporary document
+        saved = DocumentUndo::getUndoSensitive(doc.get());
+        DocumentUndo::setUndoSensitive(doc.get(), false); // No need to undo in this temporary document
 #endif
     }
 
@@ -734,7 +745,7 @@ PdfInput::open(::Inkscape::Extension::In
     }
 
     // Restore undo
-    DocumentUndo::setUndoSensitive(doc, saved);
+    DocumentUndo::setUndoSensitive(doc.get(), saved);
 
     return doc;
 }
@@ -780,7 +791,7 @@ PdfInput::add_builder_page(std::shared_p
     }
 
     // Create parser  (extension/internal/pdfinput/pdf-parser.h)
-    PdfParser *pdf_parser = new PdfParser(pdf_doc, builder, page, clipToBox);
+    auto pdf_parser = PdfParser(pdf_doc, builder, page, clipToBox);
 
     // Set up approximation precision for parser. Used for converting Mesh Gradients into tiles.
     double color_delta = prefs->getAttributeDouble("approximationPrecision", 2.0);
@@ -790,25 +801,22 @@ PdfInput::add_builder_page(std::shared_p
         color_delta = 1.0 / color_delta;
     }
     for ( int i = 1 ; i <= pdfNumShadingTypes ; i++ ) {
-        pdf_parser->setApproximationPrecision(i, color_delta, 6);
+        pdf_parser.setApproximationPrecision(i, color_delta, 6);
     }
 
     // Parse the document structure
-#if defined(POPPLER_NEW_OBJECT_API)
     Object obj = page->getContents();
-#else
-    Object obj;
-    page->getContents(&obj);
-#endif
     if (!obj.isNull()) {
-        pdf_parser->parse(&obj);
+        pdf_parser.parse(&obj);
     }
 
-    // Cleanup
-#if !defined(POPPLER_NEW_OBJECT_API)
-    obj.free();
-#endif
-    delete pdf_parser;
+    // Parse the annotations
+    if (auto annots = page->getAnnotsObject(); annots.isArray()) {
+        auto const size = annots.arrayGetLength();
+        for (int i = 0; i < size; i++) {
+            pdf_parser.build_annots(annots.arrayGet(i), page_num);
+        }
+    }
 }
 
 #include "../clear-n_.h"
@@ -826,7 +834,7 @@ void PdfInput::init() {
                 "<filetypename>" N_("Portable Document Format (*.pdf)") "</filetypename>\n"
                 "<filetypetooltip>" N_("Portable Document Format") "</filetypetooltip>\n"
             "</input>\n"
-        "</inkscape-extension>", new PdfInput());
+        "</inkscape-extension>", std::make_unique<PdfInput>());
     // clang-format on
 
     /* AI in */
@@ -841,7 +849,7 @@ void PdfInput::init() {
                 "<filetypename>" N_("Adobe Illustrator 9.0 and above (*.ai)") "</filetypename>\n"
                 "<filetypetooltip>" N_("Open files saved in Adobe Illustrator 9.0 and newer versions") "</filetypetooltip>\n"
             "</input>\n"
-        "</inkscape-extension>", new PdfInput());
+        "</inkscape-extension>", std::make_unique<PdfInput>());
     // clang-format on
 } // init
 
--- a/src/extension/internal/pdfinput/pdf-input.h	2023-11-16 20:05:21.000000000 +0100
+++ b/src/extension/internal/pdfinput/pdf-input.h	2024-05-23 14:17:28.669307494 +0200
@@ -1,7 +1,4 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
-#ifndef SEEN_EXTENSION_INTERNAL_PDFINPUT_H
-#define SEEN_EXTENSION_INTERNAL_PDFINPUT_H
-
 /*
  * Authors:
  *   miklos erdelyi
@@ -11,51 +8,61 @@
  * Released under GNU GPL v2+, read the file 'COPYING' for more information.
  */
 
+#ifndef SEEN_EXTENSION_INTERNAL_PDFINPUT_H
+#define SEEN_EXTENSION_INTERNAL_PDFINPUT_H
+
 #ifdef HAVE_CONFIG_H
 # include "config.h"  // only include where actually required!
 #endif
 
 #ifdef HAVE_POPPLER
-#include <gtkmm.h>
+
+#include <glibmm/refptr.h>
 #include <gtkmm/dialog.h>
+#include <unordered_map>
 
-#include "../../implementation/implementation.h"
-#include "poppler-transition-api.h"
+#include "extension/implementation/implementation.h"
+#include "async/channel.h"
 #include "poppler-utils.h"
 #include "svg-builder.h"
 
+namespace Gtk {
+class Builder;
+class Button;
+class CheckButton;
+class DrawingArea;
+class Entry;
+class Label;
+class ListStore;
+class Scale;
+} // namespace Gtk
+
 #ifdef HAVE_POPPLER_CAIRO
 struct _PopplerDocument;
 typedef struct _PopplerDocument            PopplerDocument;
 #endif
 
-struct _GdkEventExpose;
-typedef _GdkEventExpose GdkEventExpose;
-
 class Page;
 class PDFDoc;
 
 namespace Gtk {
-  class Button;
-  class CheckButton;
-  class ComboBoxText;
-  class DrawingArea;
-  class Frame;
-  class Scale;
-  class RadioButton;
-  class Box;
-  class Label;
-  class Entry;
-}
+class Button;
+class CheckButton;
+class ComboBoxText;
+class DrawingArea;
+class Frame;
+class Scale;
+class Box;
+class Label;
+class Entry;
+} // namespace Gtk
 
 namespace Inkscape {
 
-namespace UI {
-namespace Widget {
-  class SpinButton;
-  class Frame;
-}
-}
+namespace UI::Widget {
+class SpinButton;
+class Frame;
+} // namespace UI::Widget
 
 enum class PdfImportType : unsigned char
 {
@@ -63,8 +70,7 @@ enum class PdfImportType : unsigned char
     PDF_IMPORT_CAIRO,
 };
 
-namespace Extension {
-namespace Internal {
+namespace Extension::Internal {
 
 class FontModelColumns;
 
@@ -90,7 +96,7 @@ private:
     void _setFonts(const FontList &fonts);
 
     // Signal handlers
-    bool _onDraw(const Cairo::RefPtr<Cairo::Context>& cr);
+    void _drawFunc(const Cairo::RefPtr<Cairo::Context>& cr, int width, int height);
     void _onPageNumberChanged();
     void _onPrecisionChanged();
 
@@ -119,18 +125,19 @@ private:
     int _preview_width, _preview_height;    // Size of the preview area
     bool _render_thumb;     // Whether we can/shall render thumbnails
 #ifdef HAVE_POPPLER_CAIRO
-    cairo_surface_t *_cairo_surface = nullptr;
+    bool _preview_rendering_in_progress = false;
+    std::unordered_map<int, std::shared_ptr<cairo_surface_t>> _cairo_surfaces;
+    std::vector<Async::Channel::Dest> _channels;
     PopplerDocument *_poppler_doc = nullptr;
 #endif
 };
 
-    
-class PdfInput: public Inkscape::Extension::Implementation::Implementation {
-    PdfInput () = default;;
+class PdfInput : public Inkscape::Extension::Implementation::Implementation
+{
 public:
-    SPDocument *open( Inkscape::Extension::Input *mod,
-                                const gchar *uri ) override;
-    static void         init( );
+    std::unique_ptr<SPDocument> open(Inkscape::Extension::Input *mod, char const *uri) override;
+    static void init();
+
 private:
     void add_builder_page(
         std::shared_ptr<PDFDoc> pdf_doc,
@@ -138,8 +145,8 @@ private:
         int page_num);
 };
 
-} // namespace Implementation
-} // namespace Extension
+} // namespace Inkscape::Extension::Internal
+
 } // namespace Inkscape
 
 #endif // HAVE_POPPLER
--- a/src/extension/internal/pdfinput/pdf-parser.cpp	2023-11-16 20:05:21.000000000 +0100
+++ b/src/extension/internal/pdfinput/pdf-parser.cpp	2024-05-23 14:17:28.669307494 +0200
@@ -16,6 +16,8 @@
 
 #ifdef HAVE_POPPLER
 
+#include "pdf-parser.h"
+
 #ifdef USE_GCC_PRAGMAS
 #pragma implementation
 #endif
@@ -25,8 +27,11 @@
 #include <cstdio>
 #include <cstdlib>
 #include <cstring>
+#include <mutex> // std::call_once()
+#include <utility>
+#include <vector>
+#include <2geom/transforms.h>
 
-#include "2geom/transforms.h"
 #include "Annot.h"
 #include "Array.h"
 #include "CharTypes.h"
@@ -46,7 +51,6 @@
 #include "glib/poppler-features.h"
 #include "goo/GooString.h"
 #include "goo/gmem.h"
-#include "pdf-parser.h"
 #include "pdf-utils.h"
 #include "poppler-cairo-font-engine.h"
 #include "poppler-transition-api.h"
@@ -681,181 +685,175 @@ void PdfParser::opSetLineWidth(Object ar
 // TODO not good that numArgs is ignored but args[] is used:
 void PdfParser::opSetExtGState(Object args[], int /*numArgs*/)
 {
-  Object obj1, obj2, obj3, obj4, obj5;
-  Function *funcs[4] = {nullptr, nullptr, nullptr, nullptr};
-  GfxColor backdropColor;
-  GBool haveBackdropColor = gFalse;
-  GBool alpha = gFalse;
+    Object obj1, obj2, obj3, obj4, obj5;
+    Function *funcs[4] = {nullptr, nullptr, nullptr, nullptr};
+    GfxColor backdropColor;
+    GBool haveBackdropColor = gFalse;
+    GBool alpha = gFalse;
 
-  _POPPLER_CALL_ARGS(obj1, res->lookupGState, args[0].getName());
-  if (obj1.isNull()) {
-    return;
-  }
-  if (!obj1.isDict()) {
-    error(errSyntaxError, getPos(), "ExtGState '{0:s}' is wrong type"), args[0].getName();
-    _POPPLER_FREE(obj1);
-    return;
-  }
-  if (printCommands) {
-    printf("  gfx state dict: ");
-    obj1.print();
-    printf("\n");
-  }
+    _POPPLER_CALL_ARGS(obj1, res->lookupGState, args[0].getName());
+    if (obj1.isNull()) {
+        return;
+    }
+    if (!obj1.isDict()) {
+        error(errSyntaxError, getPos(), "ExtGState '{0:s}' is wrong type"), args[0].getName();
+        _POPPLER_FREE(obj1);
+        return;
+    }
+    if (printCommands) {
+        printf("  gfx state dict: ");
+        obj1.print();
+        printf("\n");
+    }
 
-  // transparency support: blend mode, fill/stroke opacity
-  if (!_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "BM").isNull()) {
-    GfxBlendMode mode = gfxBlendNormal;
-    if (state->parseBlendMode(&obj2, &mode)) {
-      state->setBlendMode(mode);
-    } else {
-      error(errSyntaxError, getPos(), "Invalid blend mode in ExtGState");
+    // transparency support: blend mode, fill/stroke opacity
+    if (!_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "BM").isNull()) {
+        GfxBlendMode mode = gfxBlendNormal;
+        if (state->parseBlendMode(&obj2, &mode)) {
+            state->setBlendMode(mode);
+        } else {
+            error(errSyntaxError, getPos(), "Invalid blend mode in ExtGState");
+        }
+    }
+    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "ca").isNum()) {
+        state->setFillOpacity(obj2.getNum());
+    }
+    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "CA").isNum()) {
+        state->setStrokeOpacity(obj2.getNum());
     }
-  }
-  _POPPLER_FREE(obj2);
-  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "ca").isNum()) {
-    state->setFillOpacity(obj2.getNum());
-  }
-  _POPPLER_FREE(obj2);
-  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "CA").isNum()) {
-    state->setStrokeOpacity(obj2.getNum());
-  }
-  _POPPLER_FREE(obj2);
 
-  // fill/stroke overprint
-  GBool haveFillOP = gFalse;
-  if ((haveFillOP = _POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "op").isBool())) {
-    state->setFillOverprint(obj2.getBool());
-  }
-  _POPPLER_FREE(obj2);
-  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "OP").isBool()) {
-    state->setStrokeOverprint(obj2.getBool());
-    if (!haveFillOP) {
-      state->setFillOverprint(obj2.getBool());
+    // fill/stroke overprint
+    GBool haveFillOP = gFalse;
+    if ((haveFillOP = _POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "op").isBool())) {
+        state->setFillOverprint(obj2.getBool());
+    }
+    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "OP").isBool()) {
+        state->setStrokeOverprint(obj2.getBool());
+        if (!haveFillOP) {
+            state->setFillOverprint(obj2.getBool());
+        }
     }
-  }
-  _POPPLER_FREE(obj2);
 
-  // stroke adjust
-  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "SA").isBool()) {
-    state->setStrokeAdjust(obj2.getBool());
-  }
-  _POPPLER_FREE(obj2);
+    // stroke adjust
+    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "SA").isBool()) {
+        state->setStrokeAdjust(obj2.getBool());
+    }
 
-  // transfer function
-  if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "TR2").isNull()) {
-    _POPPLER_FREE(obj2);
-    _POPPLER_CALL_ARGS(obj2, obj1.dictLookup, "TR");
-  }
-  if (obj2.isName(const_cast<char*>("Default")) ||
-      obj2.isName(const_cast<char*>("Identity"))) {
-    funcs[0] = funcs[1] = funcs[2] = funcs[3] = nullptr;
-    state->setTransfer(funcs);
-  } else if (obj2.isArray() && obj2.arrayGetLength() == 4) {
-    int pos = 4;
-    for (int i = 0; i < 4; ++i) {
-      _POPPLER_CALL_ARGS(obj3, obj2.arrayGet, i);
-      funcs[i] = Function::parse(&obj3);
-      _POPPLER_FREE(obj3);
-      if (!funcs[i]) {
-	pos = i;
-	break;
-      }
+    // Stroke width
+    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "LW").isNum()) {
+        state->setLineWidth(obj2.getNum());
     }
-    if (pos == 4) {
-      state->setTransfer(funcs);
+
+    // transfer function
+    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "TR2").isNull()) {
+        _POPPLER_CALL_ARGS(obj2, obj1.dictLookup, "TR");
     }
-  } else if (obj2.isName() || obj2.isDict() || obj2.isStream()) {
-    if ((funcs[0] = Function::parse(&obj2))) {
-      funcs[1] = funcs[2] = funcs[3] = nullptr;
-      state->setTransfer(funcs);
-    }
-  } else if (!obj2.isNull()) {
-    error(errSyntaxError, getPos(), "Invalid transfer function in ExtGState");
-  }
-  _POPPLER_FREE(obj2);
-
-  // soft mask
-  if (!_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "SMask").isNull()) {
-    if (obj2.isName(const_cast<char*>("None"))) {
-        // Do nothing.
-    } else if (obj2.isDict()) {
-      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "S").isName("Alpha")) {
-	alpha = gTrue;
-      } else { // "Luminosity"
-	alpha = gFalse;
-      }
-      _POPPLER_FREE(obj3);
-      funcs[0] = nullptr;
-      if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "TR").isNull()) {
-	funcs[0] = Function::parse(&obj3);
-	if (funcs[0]->getInputSize() != 1 ||
-	    funcs[0]->getOutputSize() != 1) {
-	  error(errSyntaxError, getPos(), "Invalid transfer function in soft mask in ExtGState");
-	  delete funcs[0];
-	  funcs[0] = nullptr;
-	}
-      }
-      _POPPLER_FREE(obj3);
-      if ((haveBackdropColor = _POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "BC").isArray())) {
-	for (int & i : backdropColor.c) {
-	  i = 0;
-	}
-	for (int i = 0; i < obj3.arrayGetLength() && i < gfxColorMaxComps; ++i) {
-          _POPPLER_CALL_ARGS(obj4, obj3.arrayGet, i);
-	  if (obj4.isNum()) {
-	    backdropColor.c[i] = dblToCol(obj4.getNum());
-	  }
-	  _POPPLER_FREE(obj4);
-	}
-      }
-      _POPPLER_FREE(obj3);
-      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "G").isStream()) {
-	if (_POPPLER_CALL_ARGS_DEREF(obj4, obj3.streamGetDict()->lookup, "Group").isDict()) {
-	  GfxColorSpace *blendingColorSpace = nullptr;
-	  GBool isolated = gFalse;
-	  GBool knockout = gFalse;
-	  if (!_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "CS").isNull()) {
-	    blendingColorSpace = GfxColorSpace::parse(nullptr, &obj5, nullptr, state);
-	  }
-          _POPPLER_FREE(obj5);
-	  if (_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "I").isBool()) {
-	    isolated = obj5.getBool();
-	  }
-          _POPPLER_FREE(obj5);
-	  if (_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "K").isBool()) {
-	    knockout = obj5.getBool();
-	  }
-	  _POPPLER_FREE(obj5);
-	  if (!haveBackdropColor) {
-	    if (blendingColorSpace) {
-	      blendingColorSpace->getDefaultColor(&backdropColor);
-	    } else {
-	      //~ need to get the parent or default color space (?)
-	      for (int & i : backdropColor.c) {
-		i = 0;
-	      }
-	    }
-	  }
-	  doSoftMask(&obj3, alpha, blendingColorSpace,
-		     isolated, knockout, funcs[0], &backdropColor);
-	  if (funcs[0]) {
-	    delete funcs[0];
-	  }
-	} else {
-	  error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState - missing group");
-	}
-	_POPPLER_FREE(obj4);
-      } else {
-	error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState - missing group");
-      }
-      _POPPLER_FREE(obj3);
+    if (obj2.isName(const_cast<char *>("Default")) || obj2.isName(const_cast<char *>("Identity"))) {
+        funcs[0] = funcs[1] = funcs[2] = funcs[3] = nullptr;
+        state->setTransfer(funcs);
+    } else if (obj2.isArray() && obj2.arrayGetLength() == 4) {
+        int pos = 4;
+        for (int i = 0; i < 4; ++i) {
+            _POPPLER_CALL_ARGS(obj3, obj2.arrayGet, i);
+            funcs[i] = Function::parse(&obj3);
+            if (!funcs[i]) {
+                pos = i;
+                break;
+            }
+        }
+        _POPPLER_FREE(obj3);
+        if (pos == 4) {
+            state->setTransfer(funcs);
+        }
+    } else if (obj2.isName() || obj2.isDict() || obj2.isStream()) {
+        if ((funcs[0] = Function::parse(&obj2))) {
+            funcs[1] = funcs[2] = funcs[3] = nullptr;
+            state->setTransfer(funcs);
+        }
     } else if (!obj2.isNull()) {
-      error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState");
+        error(errSyntaxError, getPos(), "Invalid transfer function in ExtGState");
     }
-  }
-  _POPPLER_FREE(obj2);
 
-  _POPPLER_FREE(obj1);
+    // soft mask
+    if (!_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "SMask").isNull()) {
+        if (obj2.isName(const_cast<char *>("None"))) {
+            // Do nothing.
+        } else if (obj2.isDict()) {
+            if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "S").isName("Alpha")) {
+                alpha = gTrue;
+            } else { // "Luminosity"
+                alpha = gFalse;
+            }
+            _POPPLER_FREE(obj3);
+            funcs[0] = nullptr;
+            if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "TR").isNull()) {
+                funcs[0] = Function::parse(&obj3);
+                if (funcs[0]->getInputSize() != 1 || funcs[0]->getOutputSize() != 1) {
+                    error(errSyntaxError, getPos(), "Invalid transfer function in soft mask in ExtGState");
+                    delete funcs[0];
+                    funcs[0] = nullptr;
+                }
+            }
+            _POPPLER_FREE(obj3);
+            if ((haveBackdropColor = _POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "BC").isArray())) {
+                for (int &i : backdropColor.c) {
+                    i = 0;
+                }
+                for (int i = 0; i < obj3.arrayGetLength() && i < gfxColorMaxComps; ++i) {
+                    _POPPLER_CALL_ARGS(obj4, obj3.arrayGet, i);
+                    if (obj4.isNum()) {
+                        backdropColor.c[i] = dblToCol(obj4.getNum());
+                    }
+                    _POPPLER_FREE(obj4);
+                }
+            }
+            _POPPLER_FREE(obj3);
+            if (_POPPLER_CALL_ARGS_DEREF(obj3, obj2.dictLookup, "G").isStream()) {
+                if (_POPPLER_CALL_ARGS_DEREF(obj4, obj3.streamGetDict()->lookup, "Group").isDict()) {
+                    GfxColorSpace *blendingColorSpace = nullptr;
+                    GBool isolated = gFalse;
+                    GBool knockout = gFalse;
+                    if (!_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "CS").isNull()) {
+                        blendingColorSpace = GfxColorSpace::parse(nullptr, &obj5, nullptr, state);
+                    }
+                    _POPPLER_FREE(obj5);
+                    if (_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "I").isBool()) {
+                        isolated = obj5.getBool();
+                    }
+                    _POPPLER_FREE(obj5);
+                    if (_POPPLER_CALL_ARGS_DEREF(obj5, obj4.dictLookup, "K").isBool()) {
+                        knockout = obj5.getBool();
+                    }
+                    _POPPLER_FREE(obj5);
+                    if (!haveBackdropColor) {
+                        if (blendingColorSpace) {
+                            blendingColorSpace->getDefaultColor(&backdropColor);
+                        } else {
+                            //~ need to get the parent or default color space (?)
+                            for (int &i : backdropColor.c) {
+                                i = 0;
+                            }
+                        }
+                    }
+                    doSoftMask(&obj3, alpha, blendingColorSpace, isolated, knockout, funcs[0], &backdropColor);
+                    if (funcs[0]) {
+                        delete funcs[0];
+                    }
+                } else {
+                    error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState - missing group");
+                }
+                _POPPLER_FREE(obj4);
+            } else {
+                error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState - missing group");
+            }
+            _POPPLER_FREE(obj3);
+        } else if (!obj2.isNull()) {
+            error(errSyntaxError, getPos(), "Invalid soft mask in ExtGState");
+        }
+    }
+
+    _POPPLER_FREE(obj2);
+    _POPPLER_FREE(obj1);
 }
 
 void PdfParser::doSoftMask(Object *str, GBool alpha,
@@ -947,8 +945,8 @@ GfxColorSpace *PdfParser::lookupColorSpa
     GfxColorSpace *colorSpace = nullptr;
 
     if (char const *name = arg.isName() ? arg.getName() : nullptr) {
-        auto cache_name = std::to_string(formDepth) + "-" + std::string(name);
-        if (colorSpace = colorSpacesCache[cache_name].get()) {
+        auto const cache_name = std::to_string(formDepth) + "-" += name;
+        if ((colorSpace = colorSpacesCache[cache_name].get())) {
             return colorSpace->copy();
         }
 
@@ -2323,40 +2321,66 @@ void PdfParser::doShowText(GooString *s)
 // TODO not good that numArgs is ignored but args[] is used:
 void PdfParser::opXObject(Object args[], int /*numArgs*/)
 {
-  Object obj1, obj2, obj3, refObj;
+    Object obj1, obj2, obj3, refObj;
+    bool layered = false;
+    Inkscape::XML::Node *save;
 
 #if POPPLER_CHECK_VERSION(0,64,0)
-  const char *name = args[0].getName();
+    const char *name = args[0].getName();
 #else
-  char *name = args[0].getName();
+    char *name = args[0].getName();
 #endif
-  _POPPLER_CALL_ARGS(obj1, res->lookupXObject, name);
-  if (obj1.isNull()) {
-    return;
-  }
-  if (!obj1.isStream()) {
-    error(errSyntaxError, getPos(), "XObject '{0:s}' is wrong type", name);
+    _POPPLER_CALL_ARGS(obj1, res->lookupXObject, name);
+    if (obj1.isNull()) {
+        return;
+    }
+    if (!obj1.isStream()) {
+        error(errSyntaxError, getPos(), "XObject '{0:s}' is wrong type", name);
+        _POPPLER_FREE(obj1);
+        return;
+    }
+
+//add layer at root if xObject has type OCG
+    _POPPLER_CALL_ARGS(obj2, obj1.streamGetDict()->lookup, "OC");
+    if(obj2.isDict()){
+        auto type_dict = obj2.getDict();
+        if (type_dict->lookup("Type").isName("OCG")) {
+            std::string label = getDictString(type_dict, "Name");
+            auto visible = true;
+            if (type_dict->lookup("Usage").isDict()){
+                auto usage_dict = type_dict->lookup("Usage").getDict();
+                if (usage_dict->lookup("Print").isDict()){
+                    auto print_dict = usage_dict->lookup("Print").getDict();
+                    visible = print_dict->lookup("PrintState").isName("ON");
+                }
+            }
+            save = builder->beginLayer(label, visible);
+            layered = true;
+        }
+    }
+
+    _POPPLER_CALL_ARGS(obj2, obj1.streamGetDict()->lookup, "Subtype");
+    if (obj2.isName(const_cast<char*>("Image"))) {
+        _POPPLER_CALL_ARGS(refObj, res->lookupXObjectNF, name);
+        doImage(&refObj, obj1.getStream(), gFalse);
+        _POPPLER_FREE(refObj);
+    } else if (obj2.isName(const_cast<char*>("Form"))) {
+        doForm(&obj1);
+    } else if (obj2.isName(const_cast<char*>("PS"))) {
+        _POPPLER_CALL_ARGS(obj3, obj1.streamGetDict()->lookup, "Level1");
+    } else if (obj2.isName()) {
+        error(errSyntaxError, getPos(), "Unknown XObject subtype '{0:s}'", obj2.getName());
+    } else {
+        error(errSyntaxError, getPos(), "XObject subtype is missing or wrong type");
+    }
+
+    //End XObject layer if OC of type OCG is present
+    if (layered) {
+        builder->endLayer(save);
+    }
+
+    _POPPLER_FREE(obj2);
     _POPPLER_FREE(obj1);
-    return;
-  }
-  _POPPLER_CALL_ARGS(obj2, obj1.streamGetDict()->lookup, "Subtype");
-  if (obj2.isName(const_cast<char*>("Image"))) {
-    _POPPLER_CALL_ARGS(refObj, res->lookupXObjectNF, name);
-    doImage(&refObj, obj1.getStream(), gFalse);
-    _POPPLER_FREE(refObj);
-  } else if (obj2.isName(const_cast<char*>("Form"))) {
-    doForm(&obj1);
-  } else if (obj2.isName(const_cast<char*>("PS"))) {
-    _POPPLER_CALL_ARGS(obj3, obj1.streamGetDict()->lookup, "Level1");
-/*    out->psXObject(obj1.getStream(),
-    		   obj3.isStream() ? obj3.getStream() : (Stream *)NULL);*/
-  } else if (obj2.isName()) {
-    error(errSyntaxError, getPos(), "Unknown XObject subtype '{0:s}'", obj2.getName());
-  } else {
-    error(errSyntaxError, getPos(), "XObject subtype is missing or wrong type");
-  }
-  _POPPLER_FREE(obj2);
-  _POPPLER_FREE(obj1);
 }
 
 void PdfParser::doImage(Object * /*ref*/, Stream *str, GBool inlineImg)
@@ -2701,98 +2725,106 @@ void PdfParser::doImage(Object * /*ref*/
     error(errSyntaxError, getPos(), "Bad image parameters");
 }
 
-void PdfParser::doForm(Object *str) {
-  Dict *dict;
-  GBool transpGroup, isolated, knockout;
-  GfxColorSpace *blendingColorSpace;
-  Object matrixObj, bboxObj;
-  double m[6], bbox[4];
-  Object resObj;
-  Dict *resDict;
-  Object obj1, obj2, obj3;
-  int i;
-
-  // check for excessive recursion
-  if (formDepth > 20) {
-    return;
-  }
+void PdfParser::doForm(Object *str, double *offset)
+{
+    Dict *dict;
+    GBool transpGroup, isolated, knockout;
+    GfxColorSpace *blendingColorSpace;
+    Object matrixObj, bboxObj;
+    double m[6], bbox[4];
+    Object resObj;
+    Dict *resDict;
+    Object obj1, obj2, obj3;
+    int i;
 
-  // get stream dict
-  dict = str->streamGetDict();
+    // check for excessive recursion
+    if (formDepth > 20) {
+        return;
+    }
 
-  // check form type
-  _POPPLER_CALL_ARGS(obj1, dict->lookup, "FormType");
-  if (!(obj1.isNull() || (obj1.isInt() && obj1.getInt() == 1))) {
-    error(errSyntaxError, getPos(), "Unknown form type");
-  }
-  _POPPLER_FREE(obj1);
+    // get stream dict
+    dict = str->streamGetDict();
 
-  // get bounding box
-  _POPPLER_CALL_ARGS(bboxObj, dict->lookup, "BBox");
-  if (!bboxObj.isArray()) {
-    _POPPLER_FREE(bboxObj);
-    error(errSyntaxError, getPos(), "Bad form bounding box");
-    return;
-  }
-  for (i = 0; i < 4; ++i) {
-    _POPPLER_CALL_ARGS(obj1, bboxObj.arrayGet, i);
-    bbox[i] = obj1.getNum();
+    // check form type
+    _POPPLER_CALL_ARGS(obj1, dict->lookup, "FormType");
+    if (!(obj1.isNull() || (obj1.isInt() && obj1.getInt() == 1))) {
+        error(errSyntaxError, getPos(), "Unknown form type");
+    }
     _POPPLER_FREE(obj1);
-  }
-  _POPPLER_FREE(bboxObj);
 
-  // get matrix
-  _POPPLER_CALL_ARGS(matrixObj, dict->lookup, "Matrix");
-  if (matrixObj.isArray()) {
-    for (i = 0; i < 6; ++i) {
-      _POPPLER_CALL_ARGS(obj1, matrixObj.arrayGet, i);
-      m[i] = obj1.getNum();
-      _POPPLER_FREE(obj1);
+    // get bounding box
+    _POPPLER_CALL_ARGS(bboxObj, dict->lookup, "BBox");
+    if (!bboxObj.isArray()) {
+        _POPPLER_FREE(bboxObj);
+        error(errSyntaxError, getPos(), "Bad form bounding box");
+        return;
     }
-  } else {
-    m[0] = 1; m[1] = 0;
-    m[2] = 0; m[3] = 1;
-    m[4] = 0; m[5] = 0;
-  }
-  _POPPLER_FREE(matrixObj);
-
-  // get resources
-  _POPPLER_CALL_ARGS(resObj, dict->lookup, "Resources");
-  resDict = resObj.isDict() ? resObj.getDict() : (Dict *)nullptr;
+    for (i = 0; i < 4; ++i) {
+        _POPPLER_CALL_ARGS(obj1, bboxObj.arrayGet, i);
+        bbox[i] = obj1.getNum();
+        _POPPLER_FREE(obj1);
+    }
+    _POPPLER_FREE(bboxObj);
 
-  // check for a transparency group
-  transpGroup = isolated = knockout = gFalse;
-  blendingColorSpace = nullptr;
-  if (_POPPLER_CALL_ARGS_DEREF(obj1, dict->lookup, "Group").isDict()) {
-    if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "S").isName("Transparency")) {
-      transpGroup = gTrue;
-      if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "CS").isNull()) {
-	blendingColorSpace = GfxColorSpace::parse(nullptr, &obj3, nullptr, state);
-      }
-      _POPPLER_FREE(obj3);
-      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "I").isBool()) {
-	isolated = obj3.getBool();
-      }
-      _POPPLER_FREE(obj3);
-      if (_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "K").isBool()) {
-	knockout = obj3.getBool();
-      }
-      _POPPLER_FREE(obj3);
+    // get matrix
+    _POPPLER_CALL_ARGS(matrixObj, dict->lookup, "Matrix");
+    if (matrixObj.isArray()) {
+        for (i = 0; i < 6; ++i) {
+        _POPPLER_CALL_ARGS(obj1, matrixObj.arrayGet, i);
+        m[i] = obj1.getNum();
+        _POPPLER_FREE(obj1);
+        }
+    } else {
+        m[0] = 1;
+        m[1] = 0;
+        m[2] = 0;
+        m[3] = 1;
+        m[4] = 0;
+        m[5] = 0;
+    }
+    _POPPLER_FREE(matrixObj);
+
+    if (offset) {
+        m[4] += offset[0];
+        m[5] += offset[1];
+    }
+
+    // get resources
+    _POPPLER_CALL_ARGS(resObj, dict->lookup, "Resources");
+    resDict = resObj.isDict() ? resObj.getDict() : (Dict *)nullptr;
+
+    // check for a transparency group
+    transpGroup = isolated = knockout = gFalse;
+    blendingColorSpace = nullptr;
+    if (_POPPLER_CALL_ARGS_DEREF(obj1, dict->lookup, "Group").isDict()) {
+        if (_POPPLER_CALL_ARGS_DEREF(obj2, obj1.dictLookup, "S").isName("Transparency")) {
+        transpGroup = gTrue;
+        if (!_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "CS").isNull()) {
+                blendingColorSpace = GfxColorSpace::parse(nullptr, &obj3, nullptr, state);
+        }
+        _POPPLER_FREE(obj3);
+        if (_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "I").isBool()) {
+                isolated = obj3.getBool();
+        }
+        _POPPLER_FREE(obj3);
+        if (_POPPLER_CALL_ARGS_DEREF(obj3, obj1.dictLookup, "K").isBool()) {
+                knockout = obj3.getBool();
+        }
+        _POPPLER_FREE(obj3);
+        }
+        _POPPLER_FREE(obj2);
     }
-    _POPPLER_FREE(obj2);
-  }
-  _POPPLER_FREE(obj1);
+    _POPPLER_FREE(obj1);
 
-  // draw it
-  ++formDepth;
-  doForm1(str, resDict, m, bbox,
-	  transpGroup, gFalse, blendingColorSpace, isolated, knockout);
-  --formDepth;
+    // draw it
+    ++formDepth;
+    doForm1(str, resDict, m, bbox, transpGroup, gFalse, blendingColorSpace, isolated, knockout);
+    --formDepth;
 
-  if (blendingColorSpace) {
-    delete blendingColorSpace;
-  }
-  _POPPLER_FREE(resObj);
+    if (blendingColorSpace) {
+        delete blendingColorSpace;
+    }
+    _POPPLER_FREE(resObj);
 }
 
 void PdfParser::doForm1(Object *str, Dict *resDict, double *matrix, double *bbox, GBool transpGroup, GBool softMask,
@@ -3144,3 +3176,59 @@ void PdfParser::loadColorProfile()
 }
 
 #endif /* HAVE_POPPLER */
+
+void PdfParser::build_annots(const Object &annot, int page_num)
+{
+    Object AP_obj, N_obj, Rect_obj, xy_obj, first_state_obj;
+    double offset[2];
+    Dict *annot_dict;
+    Inkscape::XML::Node *current_node;
+
+    if (!annot.isDict())
+        return;
+    annot_dict = annot.getDict();
+
+    _POPPLER_CALL_ARGS(AP_obj, annot_dict->lookup, "AP");
+    // If AP stream is present we use it
+    if (AP_obj.isDict()) {
+        _POPPLER_CALL_ARGS(N_obj, AP_obj.getDict()->lookup, "N");
+        if (N_obj.isDict()) {
+            // If there are several appearance states, we draw the first one
+            _POPPLER_CALL_ARGS(first_state_obj, N_obj.getDict()->getVal, 0);
+        } else {
+            // If there is only one appearance state, we get directly the stream
+            first_state_obj = N_obj.copy();
+        }
+        if (first_state_obj.isStream()) {
+            current_node = builder->beginLayer(std::to_string(page_num) + " - Annotations", true);
+            _POPPLER_CALL_ARGS(Rect_obj, annot_dict->lookup, "Rect");
+            if (Rect_obj.isArray()) {
+                for (int i = 0; i < 2; i++) {
+                    _POPPLER_CALL_ARGS(xy_obj, Rect_obj.arrayGet, i);
+                    offset[i] = xy_obj.getNum();
+                }
+                doForm(&first_state_obj, offset);
+            }
+            builder->endLayer(current_node);
+        }
+        _POPPLER_FREE(AP_obj);
+        _POPPLER_FREE(N_obj);
+        _POPPLER_FREE(Rect_obj);
+        _POPPLER_FREE(xy_obj);
+        _POPPLER_FREE(first_state_obj);
+    } else {
+        // No AP stream, we need to implement a Inkscape annotation handler for annot type
+        error(errInternal, -1, "No inkscape handler for this annotation type");
+    }
+}
+
+/*
+  Local Variables:
+  mode:c++
+  c-file-style:"stroustrup"
+  c-file-offsets:((innamespace . 0)(inline-open . 0)(case-label . +))
+  indent-tabs-mode:nil
+  fill-column:99
+  End:
+*/
+// vim:filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:fileencoding=utf-8:textwidth=99:
--- a/src/extension/internal/pdfinput/pdf-parser.h	2023-11-16 20:05:21.000000000 +0100
+++ b/src/extension/internal/pdfinput/pdf-parser.h	2024-05-23 14:17:28.669307494 +0200
@@ -25,43 +25,36 @@
 #pragma interface
 #endif
 
-namespace Inkscape {
-    namespace Extension {
-        namespace Internal {
-                class SvgBuilder;
-        }
-    }
-}
-
-// TODO clean up and remove using:
-using Inkscape::Extension::Internal::SvgBuilder;
-
 #include "glib/poppler-features.h"
 #include "Object.h"
 
 #include <map>
 #include <memory>
 #include <string>
+#include <2geom/affine.h>
 
 #define Operator Operator_Gfx
 #include <Gfx.h>
 #undef Operator
 
+namespace Inkscape::Extension::Internal {
+class SvgBuilder;
+} // namespace Inkscape::Extension::Internal
+
+// TODO clean up and remove using:
+using Inkscape::Extension::Internal::SvgBuilder;
+
 class PDFDoc;
 class Page;
 class GooString;
 class XRef;
-class Array;
 class Stream;
 class Parser;
 class Dict;
 class Function;
 class OutputDev;
-class GfxFont;
 class GfxPattern;
-class GfxTilingPattern;
 class GfxShadingPattern;
-class GfxShading;
 class GfxFunctionShading;
 class GfxAxialShading;
 class GfxRadialShading;
@@ -71,10 +64,8 @@ struct GfxPatch;
 class GfxState;
 struct GfxColor;
 class GfxColorSpace;
-class Gfx;
 class GfxResources;
 class PDFRectangle;
-class AnnotBorderStyle;
 class CairoFontEngine;
 
 class PdfParser;
@@ -150,6 +141,10 @@ public:
     GfxPattern *lookupPattern(Object *obj, GfxState *state);
 
     std::shared_ptr<CairoFontEngine> getFontEngine();
+
+    // Build all annotations provided in layer annotation - page_num
+    void build_annots(const Object &annot, int page_num);
+
 private:
     std::shared_ptr<PDFDoc> _pdf_doc;
     std::shared_ptr<CairoFontEngine> _font_engine;
@@ -299,7 +294,7 @@ private:
   // XObject operators
   void opXObject(Object args[], int numArgs);
   void doImage(Object *ref, Stream *str, GBool inlineImg);
-  void doForm(Object *str);
+  void doForm(Object *str, double *offset = nullptr);
   void doForm1(Object *str, Dict *resDict, double *matrix, double *bbox,
 	       GBool transpGroup = gFalse, GBool softMask = gFalse,
 	       GfxColorSpace *blendingColorSpace = nullptr,
@@ -333,3 +328,14 @@ private:
 #endif /* HAVE_POPPLER */
 
 #endif /* PDF_PARSER_H */
+
+/*
+  Local Variables:
+  mode:c++
+  c-file-style:"stroustrup"
+  c-file-offsets:((innamespace . 0)(inline-open . 0)(case-label . +))
+  indent-tabs-mode:nil
+  fill-column:99
+  End:
+*/
+// vim:filetype=cpp:expandtab:shiftwidth=4:tabstop=8:softtabstop=4:fileencoding=utf-8:textwidth=99:
--- a/src/extension/internal/pdfinput/poppler-transition-api.h	2022-04-05 21:25:39.000000000 +0200
+++ b/src/extension/internal/pdfinput/poppler-transition-api.h	2024-05-23 14:17:28.670307477 +0200
@@ -13,6 +13,25 @@
 #define SEEN_POPPLER_TRANSITION_API_H
 
 #include <glib/poppler-features.h>
+#include <poppler/UTF.h>
+
+#if POPPLER_CHECK_VERSION(24, 5, 0)
+#define _POPPLER_HAS_UNICODE_BOM(value) (hasUnicodeByteOrderMark(value->toStr()))
+#define _POPPLER_HAS_UNICODE_BOMLE(value) (hasUnicodeByteOrderMarkLE(value->toStr()))
+#else
+#define _POPPLER_HAS_UNICODE_BOM(value) (value->hasUnicodeMarker())
+#define _POPPLER_HAS_UNICODE_BOMLE(value) (value->hasUnicodeMarkerLE())
+#endif
+
+#if POPPLER_CHECK_VERSION(24, 3, 0)
+#define _POPPLER_FUNCTION_TYPE_SAMPLED Function::Type::Sampled
+#define _POPPLER_FUNCTION_TYPE_EXPONENTIAL Function::Type::Exponential
+#define _POPPLER_FUNCTION_TYPE_STITCHING Function::Type::Stitching
+#else
+#define _POPPLER_FUNCTION_TYPE_SAMPLED 0
+#define _POPPLER_FUNCTION_TYPE_EXPONENTIAL 2
+#define _POPPLER_FUNCTION_TYPE_STITCHING 3
+#endif
 
 #if POPPLER_CHECK_VERSION(22, 4, 0)
 #define _POPPLER_FONTPTR_TO_GFX8(font_ptr) ((Gfx8BitFont *)font_ptr.get())
@@ -75,21 +94,14 @@ typedef bool GBool;
 #define _POPPLER_DICTADD(dict, key, obj) (dict).dictAdd(copyString(key), &obj)
 #endif
 
-#if POPPLER_CHECK_VERSION(0,58,0)
 #define POPPLER_NEW_OBJECT_API
 #define _POPPLER_FREE(obj)
 #define _POPPLER_CALL(ret, func) (ret = func())
 #define _POPPLER_CALL_ARGS(ret, func, ...) (ret = func(__VA_ARGS__))
 #define _POPPLER_CALL_ARGS_DEREF _POPPLER_CALL_ARGS
-#else
-#define _POPPLER_FREE(obj) (obj).free()
-#define _POPPLER_CALL(ret, func) (*func(&ret))
-#define _POPPLER_CALL_ARGS(ret, func, ...) (func(__VA_ARGS__, &ret))
-#define _POPPLER_CALL_ARGS_DEREF(...) (*_POPPLER_CALL_ARGS(__VA_ARGS__))
-#endif
 
-#if !POPPLER_CHECK_VERSION(0, 29, 0)
-#error "Requires poppler >= 0.29"
+#if !POPPLER_CHECK_VERSION(0, 58, 0)
+#error "Requires poppler >= 0.58"
 #endif
 
 #endif
--- a/src/extension/internal/pdfinput/poppler-utils.cpp	2023-10-28 16:52:00.000000000 +0200
+++ b/src/extension/internal/pdfinput/poppler-utils.cpp	2024-05-23 14:17:28.670307477 +0200
@@ -12,6 +12,8 @@
 
 #include "poppler-utils.h"
 
+#include <poppler/UTF.h>
+
 #include "2geom/affine.h"
 #include "GfxFont.h"
 #include "GfxState.h"
@@ -563,10 +565,10 @@ std::string getDictString(Dict *dict, co
  */
 std::string getString(const GooString *value)
 {
-    if (value->hasUnicodeMarker()) {
+    if (_POPPLER_HAS_UNICODE_BOM(value)) {
         return g_convert(value->getCString () + 2, value->getLength () - 2,
                          "UTF-8", "UTF-16BE", NULL, NULL, NULL);
-    } else if (value->hasUnicodeMarkerLE()) {
+    } else if (_POPPLER_HAS_UNICODE_BOMLE(value)) {
         return g_convert(value->getCString () + 2, value->getLength () - 2,
                          "UTF-8", "UTF-16LE", NULL, NULL, NULL);
     }
--- a/src/extension/internal/pdfinput/svg-builder.cpp	2023-11-16 20:05:21.000000000 +0100
+++ b/src/extension/internal/pdfinput/svg-builder.cpp	2024-05-23 14:17:28.670307477 +0200
@@ -12,6 +12,8 @@
  *
  */
 
+#include "svg-builder.h"
+
 #ifdef HAVE_CONFIG_H
 # include "config.h"  // only include where actually required!
 #endif
@@ -21,35 +23,29 @@
 #include <codecvt>
 
 #ifdef HAVE_POPPLER
-#define USE_CMS
 
 #include "Function.h"
 #include "GfxFont.h"
 #include "GfxState.h"
-#include "GlobalParams.h"
 #include "Page.h"
 #include "Stream.h"
-#include "UnicodeMap.h"
 #include "color.h"
-#include "display/cairo-utils.h"
-#include "display/nr-filter-utils.h"
 #include "document.h"
 #include "extract-uri.h"
-#include "libnrtype/font-factory.h"
-#include "libnrtype/font-instance.h"
-#include "object/color-profile.h"
-#include "object/sp-defs.h"
-#include "object/sp-item-group.h"
-#include "object/sp-namedview.h"
 #include "pdf-parser.h"
 #include "pdf-utils.h"
 #include "png.h"
 #include "poppler-cairo-font-engine.h"
 #include "profile-manager.h"
-#include "svg-builder.h"
+
+#include "color/cms-util.h"
+#include "display/cairo-utils.h"
+#include "display/nr-filter-utils.h"
+#include "object/sp-defs.h"
+#include "object/sp-item-group.h"
+#include "object/sp-namedview.h"
 #include "svg/css-ostringstream.h"
 #include "svg/path-string.h"
-#include "svg/svg-color.h"
 #include "svg/svg.h"
 #include "util/units.h"
 #include "xml/document.h"
@@ -874,6 +870,29 @@ void SvgBuilder::addOptionalGroup(const
     _ocgs[oc] = {label, visible};
 }
 
+Inkscape::XML::Node *SvgBuilder::beginLayer(const std::string &label, bool visible)
+{
+    Inkscape::XML::Node *save_current_location = _container;
+    if (auto existing = _doc->getObjectById(label)){
+        _container = existing->getRepr();
+        _node_stack.push_back(_container);
+    } else {
+        while (_container != _root) {
+            _popGroup();
+        }
+        auto node = _pushGroup();
+        node->setAttribute("id", label.c_str());
+        setAsLayer(label.c_str(), visible);
+    } 
+    return save_current_location;
+}
+
+void SvgBuilder::endLayer(Inkscape::XML::Node *save)
+{
+    _popGroup();
+    _node_stack.push_back(save);
+}
+
 void SvgBuilder::endMarkedContent()
 {
     _popGroup();
@@ -901,8 +920,7 @@ std::string SvgBuilder::_getColorProfile
     if (_icc_profiles.find(hp) != _icc_profiles.end())
         return _icc_profiles[hp];
 
-    std::string name = Inkscape::ColorProfile::getNameFromProfile(hp);
-    Inkscape::ColorProfile::sanitizeName(name);
+    std::string name = get_color_profile_name(hp);
 
     // Find the named profile in the document (if already added)
     if (_doc->getProfileManager().find(name.c_str()))
@@ -915,8 +933,7 @@ std::string SvgBuilder::_getColorProfile
     cmsSaveProfileToMem(hp, buf, &len);
 
     Inkscape::XML::Node *icc_node = _xml_doc->createElement("svg:color-profile");
-    std::string label = Inkscape::ColorProfile::getNameFromProfile(hp);
-    icc_node->setAttribute("inkscape:label", label);
+    icc_node->setAttribute("inkscape:label", name);
     icc_node->setAttribute("name", name);
 
     auto *base64String = g_base64_encode(buf, len);
@@ -1158,9 +1175,9 @@ static bool svgGetShadingColor(GfxShadin
 #define INT_EPSILON 8
 bool SvgBuilder::_addGradientStops(Inkscape::XML::Node *gradient, GfxShading *shading,
                                    _POPPLER_CONST Function *func) {
-    int type = func->getType();
+    auto type = func->getType();
     auto space = shading->getColorSpace();
-    if ( type == 0 || type == 2 ) {  // Sampled or exponential function
+    if (type == _POPPLER_FUNCTION_TYPE_SAMPLED || type == _POPPLER_FUNCTION_TYPE_EXPONENTIAL) {
         GfxColor stop1, stop2;
         if (!svgGetShadingColor(shading, 0.0, &stop1) || !svgGetShadingColor(shading, 1.0, &stop2)) {
             return false;
@@ -1168,7 +1185,7 @@ bool SvgBuilder::_addGradientStops(Inksc
             _addStopToGradient(gradient, 0.0, &stop1, space, 1.0);
             _addStopToGradient(gradient, 1.0, &stop2, space, 1.0);
         }
-    } else if ( type == 3 ) { // Stitching
+    } else if (type == _POPPLER_FUNCTION_TYPE_STITCHING) {
         auto stitchingFunc = static_cast<_POPPLER_CONST StitchingFunction*>(func);
         const double *bounds = stitchingFunc->getBounds();
         const double *encode = stitchingFunc->getEncode();
@@ -1183,7 +1200,7 @@ bool SvgBuilder::_addGradientStops(Inksc
         for ( int i = 0 ; i < num_funcs ; i++ ) {
             svgGetShadingColor(shading, bounds[i + 1], &color);
             // Add stops
-            if (stitchingFunc->getFunc(i)->getType() == 2) {    // process exponential fxn
+            if (stitchingFunc->getFunc(i)->getType() == _POPPLER_FUNCTION_TYPE_EXPONENTIAL) {
                 double expE = (static_cast<_POPPLER_CONST ExponentialFunction*>(stitchingFunc->getFunc(i)))->getE();
                 if (expE > 1.0) {
                     expE = (bounds[i + 1] - bounds[i])/expE;    // approximate exponential as a single straight line at x=1
--- a/src/extension/internal/pdfinput/svg-builder.h	2023-10-28 16:52:00.000000000 +0200
+++ b/src/extension/internal/pdfinput/svg-builder.h	2024-05-23 14:17:28.670307477 +0200
@@ -167,7 +167,9 @@ public:
 
     // Layers i.e Optional Groups
     void addOptionalGroup(const std::string &oc, const std::string &label, bool visible = true);
+    Inkscape::XML::Node *beginLayer(const std::string &label, bool visible);
     void beginMarkedContent(const char *name = nullptr, const char *group = nullptr);
+    void endLayer(Inkscape::XML::Node *save);
     void endMarkedContent();
 
     void addColorProfile(unsigned char *profBuf, int length);
